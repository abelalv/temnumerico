[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Cálculo numérico",
    "section": "",
    "text": "Aquí nosotros presentaremos los apuntes de algunos métodos numéricos que se utilizan en la Ingeniería. Los métodos numéricos son una herramienta muy útil para resolver problemas que no tienen solución analítica o que son muy complicados de resolver analíticamente."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "presentacion.html",
    "href": "presentacion.html",
    "title": "Primeros pasos con Phyton",
    "section": "",
    "text": "Antes de comenzar debemos instalar python en nuestro equipo\n\nVamos a la pagina oficial de anaconda y descargamos ultima vesrio de este software https://www.anaconda.com/products/individual\nInstalamos el software en nuestro equipo\nAbrimos una terminal y vamosa crear un entorno virtual para trabajar con python\n\n\nconda create -n python3 python=3.8\nAhora vamos a entrar al entornode trabajo\nconda activate python3\nNote que el nombre del entorno de trabajo aparece entre parentesis en la terminal. Ahora vamos a instalar jupyter notebook\nconda install -c conda-forge notebook\npara instalar la libreria numpy\nconda install -c anaconda numpy\nDesde la terminal podemos ejecutar jupyter notebook\njupyter notebook\nEsto nos abrira una ventana en el navegador donde podemos crear un nuevo notebook\n\n\n\njupyter"
  },
  {
    "objectID": "Python - Parte 1.html#entrada-y-salida",
    "href": "Python - Parte 1.html#entrada-y-salida",
    "title": "clases",
    "section": "2. Entrada y salida",
    "text": "2. Entrada y salida\nLos programas escritos en Python y los entornos de ejecución (como Google Colab) permiten al usuario interactuar de formas distintas. El usuario introduce información en forma de archivos, datos en la nube, o acciones de periféricos como el teclado y ratón, y los entornos de ejecución ejecutan el programa de Python. En consecuencia, le devuelven al usuario una respuesta en forma de texto, imagen o contenidos interactivos complejos. A continuación, conocera las funciones de entrada y salida de texto. Las más comunes y más útiles en los primeros pasos del aprendizaje del lenguaje son las funciones input y print.\nCuando se ejecuta input() la consola de Python espera que se le entregue texto, que puede escribir con su teclado o pegar del portapapeles, para luego hacer algo con este, como almacenarlo en una variable. Por otro lado, print() escribirá en consola texto que este almacenado previamente.\n\nnombre = input('Hola. ¿Cómo te llamas?\\n')\n\nHola. ¿Cómo te llamas?\nisa\n\n\n\nprint(\"¿Cómo se llama?\")\nnombre = input()\nprint(f\"Me alegro de conocerle, {nombre}\")\n\nNota: De forma predeterminada, la función input() siempre que lee algún dato, lo retorna como un string, incluso aunque sea un número válido y por ejemplo, si intentamos hacer operaciones, se producirá un error.\n\ncantidad = input(\"Dígame una cantidad en pesetas: \")\nprint(f\"{cantidad} pesetas son {round(cantidad / 166.386, 2)} euros\")\n\nPara evitar lo mencionado anteriormente, se debe convertir el dato a número (float o int) según lo que se requiera en el programa. Veamos entonces cómo leer y convertir los números de la entrada en Python.\nEjemplo: Si se quiere que Python interprete la entrada como un número entero, se debe utilizar la función int() de la siguiente manera:\n\ncantidad = int(input(\"Dígame una cantidad en pesetas: \"))\nprint(f\"{cantidad} pesetas son {round(cantidad / 166.386, 2)} euros\")\n\nEjemplo: Modifique el código anterior de tal manera que Python interprete la entrada como un float e imprima el valor con un redondeo de 3 dígitos."
  },
  {
    "objectID": "Python - Parte 1.html#tipos-de-dato-y-operadores",
    "href": "Python - Parte 1.html#tipos-de-dato-y-operadores",
    "title": "clases",
    "section": "3. Tipos de dato y operadores",
    "text": "3. Tipos de dato y operadores\n\nEl tipo de un dato es un atributo que determina qué operaciones se pueden realizar y qué valores puede tomar. Estos pueden ser números, listas, texto, entre otros. En Python, los tipos de dato no son definidos explícitamente, pero siempre están presentes en las variables que declaramos y es necesario tenerlos en cuenta. En particular, el tipo de dato define las operaciones válidas entre datos del mismo tipo. Estas operaciones están definidas con el uso de símbolos llamados operadores.\nPara conocer el tipo de dato de una variable, se usa la función type."
  },
  {
    "objectID": "Python - Parte 1.html#cadenas-de-texto",
    "href": "Python - Parte 1.html#cadenas-de-texto",
    "title": "clases",
    "section": "### 3.1. Cadenas de texto",
    "text": "### 3.1. Cadenas de texto\nUn tipo de dato muy importante es el de las cadenas de texto. Estas cadenas permiten almacenar en un mismo dato texto con cualquier cantidad de caracteres. Para definir una cadena de texto, se rodea el texto con comillas simples ' o comillas dobles \".\n\n'cadena con comilla simple'\n\n\n\"cadena con comillas dobles\"\n\nLas cadenas se pueden almacenar en variables, así:\n\nc = ' ¡Pontificia Universidad Javeriana Cali! '\n\n\nprint(c)\n\nAlgunos operadores de los usados para valores numéricos también sirven al operar con strings pero con utilidad distinta:\n\nConcatenación +.\nRepetición *.\nFormato %.\n\n\nConcatenación\n\n\nRepetición\n\n\nFormato\nEste operador permite reemplazar los marcadores de posición (%_) dentro de la string con la o las variables que se encuentren después del operador (%).\n\ntipo_calculo = \"raíz cuadrada de dos\"\nvalor = 2**0.5\nprint (\"el resultado de %s es %f\" % (tipo_calculo, valor))\n\nel resultado de raíz cuadrada de dos es 1.414214\n\n\nLas cadenas, como objetos que son, nos proporcionan métodos que nos facilitan su manipulación. Por ejemplo, siendo s una variable con un string:\n\ns.lower() : Retorna la cadena con todos los caracteres alfabéticos en minúscula.\ns.upper() : Retorna la cadena con todos los caracteres alfabéticos en mayúscula.\ns.replace(a, b) : Reemplaza las subcadenas iguales a la cadena a con el valor de la cadena b.\ns.strip() : Retorna la cadena con todos los espacios en blanco al principio y al final removidos.\ns.islower() : Determina si la cadena está compuesta solo por caracteres en mayúscula.\ns.isupper() : Determina si la cadena está compuesta solo por caracteres en mayúscula.\ns.isdigit() : Determina si la cadena está compuesta solo por dígitos del 0 al 9.\ns.isalpha() : Determina si la cadena está compuesta solo por caracteres alfabéticos.\n\nCada uno de los caracteres de una cadena (incluidos los espacios) tiene asignado un índice. Este indice nos permite seleccionar su carácter asociado haciendo referencia a él entre corchetes ([ ])\n\n\n\nimage.png\n\n\n\n\n3.2. Valores y operadores numéricos\n\nEn Python, los valores numéricos pueden ser de tres formas:\n\nNúmeros enteros. (int)\nNúmeros decimales. (float)\nNúmeros complejos. (complex)\n\n\na = 10            #int\nprint(a)\nprint(type(a))\n\n\na = -1089         #int - Se pueden escribir números negativos con el símbolo ‘-’\nprint(a)\nprint(type(a))\n\n\na = 1e100         #float - Esta sintaxis representa notación científica.\nprint(a)\nprint(type(a))\n\n1e+100\n<class 'float'>\n\n\n\na = 1 + 0.2j      #complex\nprint(a)\nprint(type(a))\n\n(1+0.2j)\n<class 'complex'>\n\n\nComo obtener la parte real e imaginaria de un numero complejo:\n\n(2.0+8.0j).real\n\n2.0\n\n\n\n(4.0+5.3j).imag\n\n5.3\n\n\nExisten varios operadores matemáticos para estos valores numéricos. Estos son:\n\n\n\nSimbolos\nOperaciones\n\n\n\n\n+\nsuma\n\n\n*\nMultiplicación\n\n\n/\nDivisión de numeros flotantes\n\n\n//\nDivisión de números enteros\n\n\n%\nMódulo\n\n\n**\nExponencial"
  },
  {
    "objectID": "Python - Parte 1.html#operados-logicos",
    "href": "Python - Parte 1.html#operados-logicos",
    "title": "clases",
    "section": "Operados logicos",
    "text": "Operados logicos\nOtro tipo de dato importante es el booleano, que representa un valor lógico de verdad. Puede tomar únicamente estos dos valores:\n\nVerdadero: True\nFalso: False\n\nEn Python, a diferencia de otros lenguajes de programación, las primitivas lógicas son escritas con la primera letra en mayúscula.\nAdemás de con el uso de las dos primitivas lógicas (True y False), se pueden obtener valores lógicos con la evaluación de expresiones con operadores relacionales. Los cuales se encuentran a continuación:\n\n\n\nSimbolos\nOperaciones\n\n\n\n\n==\nIgual\n\n\n!=\nDiferente\n\n\n<\nMenor que\n\n\n<=\nMenor igual que\n\n\n\\(>\\)\nMayor que\n\n\n\\(>=\\)\nMayor e igual que\n\n\n\n\nprint(-10  >   4.0)  # Mayor que.   \n\nFalse\n\n\n\nprint(-10  !=  4.0)  # Distinto que.\n\nTrue\n\n\n¿Puedo utilizar los operadores lógicos con string?\nPara evaluar más de una condición simultáneamente, se utilizan operadores lógicos. Estos son:\n\nAND lógico. and\nOR lógico. or\nNOT. negación. not\n\nEjemplo\nAdemás de estos operadores, se puede usar el operador is, que valida la identidad de un objeto. Para entender esto, tenemos que por su parte el operador == valida la igualdad de contenido de un objeto, mientras que el operador is valida si dos objetos, además de ser iguales en contenido, contienen la misma referencia en memoria, es decir, valida si son el mismo objeto. Si los valores son primitivas numéricas o lógicas el operador is retornará True.\n\n# Operador is\n\nprint('Operador is')\na = 1.0\nb = 1\n\nprint(a is b) # No tienen el mismo tipo de dato y por lo tanto son objetos distintos.\nprint(a == b) # Contienen el mismo valor al verificar su igualdad.\n\nOperador is\nFalse\nTrue"
  },
  {
    "objectID": "Python - Parte 2.html#condicionales-if-elif-y-else",
    "href": "Python - Parte 2.html#condicionales-if-elif-y-else",
    "title": "clases",
    "section": "1. Condicionales if, elif y else",
    "text": "1. Condicionales if, elif y else\n\nLas estructuras de control de flujo condicionales, permiten ejecutar bloques de código específicos según el valor de algunos datos. Se definen mediante el uso de tres palabras claves reservadas, del lenguaje: if (si), elif (sino, si) y else (sino).\nif test expression:\n    Body of if\nelif test expression:\n    Body of elif\nelse: \n    Body of else\nSi la condición que sigue a la palabra clave if se evalúa como verdadera , el bloque de código se ejecutará. Opcionalmente, puedes agregar una respuesta else la cual se ejecutará si la condición es false. Sin embargo, si se desea evaluar múltiples condiciones se usara la sentencia elif.\n\nEjemplo:\nTomemos un ejemplo de cómo encontrar un número que sea par y también mayor que 10\n\n'''En este programa, vamos a mirar si dado un numero \nes positivo, negativo o cero, con su respectivo mensaje '''\n\nnum = 3.4\n\nif num > 0:\n    print(\"Numero positivo\")\nelif num == 0:\n    print(\"Cero\")\nelse:\n    print(\"Numero negativo\")\n\nNumero positivo\n\n\n\n\nEjercicio 1\nEscribir un programa que almacene la cadena de caracteres contraseña en una variable, pregunte al usuario por la contraseña e imprima por pantalla si la contraseña introducida por el usuario coincide con la guardada en la variable sin tener en cuenta mayúsculas y minúsculas.\n\nLa clave debe estar en minuscula"
  },
  {
    "objectID": "Python - Parte 2.html#bucle-for",
    "href": "Python - Parte 2.html#bucle-for",
    "title": "clases",
    "section": "## 2. Bucle for",
    "text": "## 2. Bucle for\nLa estructura repetitiva For es aquella en la que el número de iteraciones se conoce por anticipado, y por ello no se precisa poner ninguna condición de salida para detener el bucle. En su lugar un contador cuenta el número de iteraciones fijas y se termina cuando llega al valor final previamente definido.\nSintaxis:\nfor <elem> in <iterable>:\n    <Código>\nAquí, elem es la variable que toma el valor del elemento dentro del iterador en cada paso del bucle. Este finaliza su ejecución cuando se recorren todos los elementos. Es frecuente usar el bucle for para iterar sobre los elementos de listas, tuplas o diccionarios.\n\nFunción range\nPara recorrer un conjunto de código un número específico de veces, podemos usar la función range(n), la cual devuelve una secuencia de números, comenzando desde 0 de forma predeterminada, se incrementa en 1 (de forma predeterminada) y termina cuando llega a n - 1.\n\nfor x in range(6):\n  print(x)\n\n0\n1\n2\n3\n4\n5\n\n\nLa función range(n) por defecto toma 0 como valor inicial, sin embargo, es posible especificar el valor inicial agregando un parámetro: range(2, 6) , lo que significa que toma valores del 2 al 6 (pero sin incluir el 6)\n\nfor x in range(2, 6):\n  print(x)\n\n2\n3\n4\n5\n\n\nLa función range(n) por defecto incrementa la secuencia en 1, sin embargo, agregando un tercer parámetro se puede especificar el valor del incremento: range(2, 30, 3 )\n\nfor x in range(1, 15, 3):\n  print(x)\n\n1\n4\n7\n10\n13\n\n\nCon for también puedo recorrer una cadena de caracteres:\n\ntexto=\"Isabella\"\nfor i in texto:\n    print(i)\n    #print(i,end=\"\")\n\nI\ns\na\nb\ne\nl\nl\na"
  },
  {
    "objectID": "Python - Parte 2.html#bucle-while",
    "href": "Python - Parte 2.html#bucle-while",
    "title": "clases",
    "section": "3. Bucle While",
    "text": "3. Bucle While\n\nEl ciclo while en Python se usa para iterar sobre un bloque de código siempre que la expresión de prueba (condición) sea verdadera. Generalmente usamos este ciclo cuando no sabemos la cantidad de veces que necesitamos iterar una sentencia.\nSintaxis:\nwhile test_expression:\n    Body of while\nEn el bucle while, primero se comprueba la expresión de prueba. El cuerpo del ciclo se ingresa solo si test_expression se evalúa como True. Después de una iteración, la expresión de prueba se verifica nuevamente. Este proceso continúa hasta que test_expression se evalue como False.\n\nx = 5\nwhile x > 0:\n    x -=1\n    print(x)\n\n4\n3\n2\n1\n0\n\n\n\nEjercicio 2\nUna empresa de ropa de la ciudad de Cali, va a lanzar una promoción sobre sus productos de la siguiente manera:\nSi el cliente compra menos de 5 productos, y si estos productos tienen un valor total menor a 100.000 COP, entonces se realizará un descuento del 10%. Si la compra es por un valor mayor o igual a 100.000 COP, el descuento es del 15% Si el cliente compra entre 5 a 10 productos, y el valor total de estos es mayor a 500.000 COP entonces se realizará un descuento del 20%, de lo contrario el descuento es del 18%. Si el cliente compra más de 10 productos y el valor total de la compra es menor a 1.000.000, el descuento será del 30%, en caso contrario el descuento es del 40%.\nEscriba un programa en Python que permita calcular el valor total a pagar del cliente teniendo en cuenta las condiciones dadas anteriormente,.\n\n\nEjercicio 3\nEscribir un programa en el que se pregunte al usuario por una frase y una letra, y muestre por pantalla el número de veces que aparece la letra en la frase.\n\n\nEjercicio 4\nRealice un programa que permita resolver la siguiente sumatoria:\n$ _{i=1}{n}(n3+n^2+3) $"
  },
  {
    "objectID": "Python - Parte 2.html#funciones",
    "href": "Python - Parte 2.html#funciones",
    "title": "clases",
    "section": "## 3. Funciones",
    "text": "## 3. Funciones\nLas funciones son bloques de código que se pueden reutilizar simplemente llamando a la función.\ndef identificador(param1, param2,..):\n    inst1\n    inst2\n    .\n    .\n    return valor\nPara definir una función en Python se utiliza la palabra reservada def. A continuación viene el nombre o identificador de la función que es el que se utiliza para invocarla dentro del código. Después del nombre hay que incluir los paréntesis y una lista opcional de parámetros. Por último, la definición de la función termina con dos puntos.\nTras los dos puntos se incluye el cuerpo de la función, en donde se encuentra el conjunto de instrucciones que se encapsulan en dicha función y finalmente, de manera opcional, se añade la instrucción con la palabra reservada return para devolver un resultado.\n\ndef new_function():\n  print(\"Hola, estoy en la función\")\n\nnew_function()\n\nHola, estoy en la función\n\n\nLas funciones permiten la reutilización de código es decir, que se evita escribir nuevamente secciones de código. Esto hace que el código sea más legible, facilita la depuración y limita los errores de escritura.\n\ndef func_name(nombre):\n  print(\" Hola,\", nombre)\n\n# Importante tener en cuenta la cantidad de argumentos que la función recibira\n\nfunc_name(\"Camilo\")\nfunc_name(\"Juan\")\nfunc_name(\"Maria\")\n\n Hola, Camilo\n Hola, Juan\n Hola, Maria\n\n\n\nEjercicio 5\nRealice un programa que pida n cantidad de numeros y por medio de un mensaje, muestre si el numero es par o no.\n\n\nReferencias:\nhttps://www.w3schools.com/PYTHON/"
  },
  {
    "objectID": "Python - Parte 3.html#listas",
    "href": "Python - Parte 3.html#listas",
    "title": "clases",
    "section": "## 4.1 Listas",
    "text": "## 4.1 Listas\nLas listas son el tipo de colección más común. Son estructuras de datos ordenadas con longitud variable. Esto quiere decir, que tras su declaración se pueden agregar o eliminar elementos específicos de su contenido. Además, estos elementos ocupan una posición definida secuencialmente, siendo el primer elemento el que ocupa la posición 0.\nExisten dos formas de declarar listas en Python: * Con llaves cuadradas.    Ejemplo: l = [] * Con la función list.      Ejemplo: l = list()\nEn el momento de su definición, se pueden definir valores por defecto, separados por coma.\n\nl = [1, 'Hola', 4.5]\nprint(l)\ntype(l)\n\n[1, 'Hola', 4.5]\n\n\nlist\n\n\nLas listas en Python son:\n\nHeterogéneas: Pueden estar conformadas por elementos de distintos tipo, incluyendo otras listas.\nMutables: Sus elementos pueden modificarse.\n\n\nl = [1, 2.5, [4, 5, 6, 7], \"Fin\"]\nprint(l)\ntype(l)\n\n[1, 2.5, [4, 5, 6, 7], 'Fin']\n\n\nlist\n\n\nLos elementos de una lista pueden accederse mediante su índice, siendo 0 el índice del primer elemento.\n\nprint(l[1])\n\nHola\n\n\nSe pueden realizar operaciones entre listas mediante algunos operadores. Es importante tener en cuenta los tipos de dato, pues símbolos como estos funcionan de manera distinta en relación al tipo de dato que manejan. Estos operadores básicos son:\n\nConcatenación +: Al aplicar este operador, se agregan los elementos de la segunda lista al final de la primera.\nRepetición *: Al aplicar este operador, se repiten los elementos la cantidad de veces expresada en el segundo operando.\n\n\nl_a = [1, 2, 3]\nl_b = ['a', 'b', 'c']\n\n\n# Concatenar\n\n\n# Repetición\n\n\nAlgunos comandos de la lista de metodos:\n\n\n\n\n\n\n\nMétodos\nDescripción\n\n\n\n\nappend(elemento)\nagregar elemento al final de la lista\n\n\nextend(lis2)\nExtiende la lista con los elementos de la lista 2\n\n\nindex(element)\nDevuelve el índice más bajo de la lista que contiene el elemento.\n\n\ninsert(index,element)\nInserta un elemento para el indice index\n\n\npop(i)\nElimina y retorna el elemento en la posición i\n\n\nreverse(element)\nInvierte la lista de lugar\n\n\nremove(element)\nElimina la primera aparición del elemento de la lista\n\n\nsort()\nClasifica la lista en lugar\n\n\ncopy()\nRetorna la copia de la lista\n\n\ncount(element)\nRetorna el némero de elementos igual al elemento de la lista\n\n\n\n\n\nUtilizar los metodos:\n\n\nInterando listas\n\nlista = [\"manzana\", \"banana\", \"cereza\"]\nfor x in lista:\n  print(x)\n\nmanzana\nbanana\ncereza"
  },
  {
    "objectID": "Python - Parte 3.html#tuplas",
    "href": "Python - Parte 3.html#tuplas",
    "title": "clases",
    "section": "4.2 Tuplas",
    "text": "4.2 Tuplas\n\nSon similares a las listas, pero lo que las diferencia es que estas son inmutables, esto quiere decir que no puede modificarse de ninguna forma después de que sean creadas. Los elementos de tupla están ordenados y permiten valores duplicados. Las tuplas se pueden definir de dos formas:\n\ntupla = (1,2,3,4)\n\n# También de esta forma\n\ntupla = tuple((1, 2, 3, 4))\n\nPara acceder a un valor dada una posición se realiza igual que con las listas, se escribe el nombre de la tupla seguido de apertura de corchetes, posición que buscamos y cierre de corchetes.\n\ntupla = tuple((1,2,3, 'r'))\nprint(tupla[1])\n\n2\n\n\nSe pueden recorrer los elementos de una tupla con for:\n\nfor dato in tupla:\n    print(dato, end=\" \")\n\n1 2 3 r \n\n\n\nFunciones de las tuplas:\nLongitud de una tupla\n\ntup = (1,2,13,-50)\nlen(tup)\n\n4\n\n\nMáximo de una tupla\n\ntup = (1,2,13,-50)\nmax(tup)\n\n13\n\n\nMinimo de una tupla\n\ntup = (1,2,13,-50)\nmin(tup)\n\n-50"
  },
  {
    "objectID": "Python - Parte 3.html#set",
    "href": "Python - Parte 3.html#set",
    "title": "clases",
    "section": "## 4.3 Set",
    "text": "## 4.3 Set\nLos conjuntos se utilizan para almacenar varios elementos en una sola variable. Un conjunto es una colección desordenada , inmutable* y no indexada.\n\nNota: Los elementos establecidos no se pueden modificar, pero puede eliminar elementos y agregar elementos nuevos.\n\n\nvocales = {'a', 'e', 'i', 'o', 'u', 'a', 'a', 'o', 'e'}\nprint(vocales)\n\nDado que los conjuntos son colecciones desordenadas, en ellos no se guarda la posición en la que son insertados los elementos como ocurre en los tipos lista o tuplas. Es por ello que no se puede acceder a los elementos a través de un índice.\nSin embargo, haciendo uso de un bucle for se puede acceder y/o recorrer todos los elementos del conjunto.\n\nprint(vocales{2})\n\nSyntaxError: invalid syntax (Temp/ipykernel_1032/3960885320.py, line 3)\n\n\n\nfor e in vocales:\n    print(e)\n\nu\na\ne\ni\no\n\n\nMetodos para utilizar en conjuntos.\n\nAgregar elementos\nUna vez que se crea un conjunto, no puede cambiar sus elementos, pero puede agregar nuevos elementos. Para agregar un elemento a un conjunto, utilice el método add().\n\nconjunto = {\"manzana\", \"cereza\", \"fresa\"}\n\nconjunto.add(\"mango\")\n\nprint(conjunto)\n\n{'manzana', 'cereza', 'mango', 'fresa'}\n\n\n\n\nAgregar conjuntos\nPara agregar elementos de otro conjunto al conjunto actual, utilice el método update(), se puede tomar como argumento una lista, tupla, string, conjunto o cualquier objeto de tipo iterable.\n\nconjunto = {\"manzana\", \"cereza\", \"fresa\"}\nlista = [\"kiwi\", \"naranja\"]\n\nconjunto.update(lista)\n\nprint(conjunto)\n\n{'fresa', 'manzana', 'naranja', 'cereza', 'kiwi'}\n\n\n\nAlgunos comandos de la lista de metodos:\n\n\n\n\n\n\n\nMétodos\nDescripción\n\n\n\n\nadd()\nAñade un elemento\n\n\nclear()\nRemueve todos los elementos\n\n\ncopy()\nEntrega una copia del set\n\n\ndifference()\nEntrega un set conteniendo los miembros diferentes entre dos o más sets\n\n\ndifference_update()\nRemueve los elementos en este set que también se incluyen en otro set específico\n\n\ndiscard()\nElimina, si existe, el elemento del conjunto.\n\n\nintersection()\nEntrega un set, que es la intersección de otros dos sets\n\n\nintersec_update()\nRemueve los elementos en este set que no se encuentran presentes en otro set específico.\n\n\nisdisjoint()\nEntrega si dos sets tienen una intersección o no\n\n\nissubset()\nEntrega si otro set contiene este set o no\n\n\nissuperset()\nEntrega si este set contiene otro set o no\n\n\npop()\nObtiene y elimina un elemento de forma aleatoria del conjunto\n\n\nremove()\nElimina el elemento del conjunto. Si no existe lanza un error.\n\n\nsymmetric_difference()\nEntrega un set con la diferencia simétrica de dos sets\n\n\nunion()\nEntrega un set que contiene la unión de dos sets\n\n\nupdate()\nActualiza el set con la unión de éste y otros sets\n\n\n\n\n\n\nUnir dos conjuntos\nHay varias formas de unir dos o más conjuntos en Python.\nPuede usar el método union() que devuelve un nuevo conjunto que contiene todos los elementos de ambos conjuntos, o el método update() que inserta todos los elementos de un conjunto en otro:\n\nset1 = {\"a\", \"b\" , \"c\"}\nset2 = {1, 2, 3}\n\nset3 = set1.union(set2)\nprint(set3)\n\n{1, 2, 'a', 3, 'b', 'c'}\n\n\nEl método update() inserta los elementos en set2 en set1:\n\nset1 = {\"a\", \"b\" , \"c\"}\nset2 = {1, 2, 3}\n\nset1.update(set2)\nprint(set1)"
  },
  {
    "objectID": "Python - Parte 3.html#diccionarios",
    "href": "Python - Parte 3.html#diccionarios",
    "title": "clases",
    "section": "4.4 Diccionarios",
    "text": "4.4 Diccionarios\n\nUn diccionario de Python es una estructura de datos para almacenar grupos de objetos. Consiste en un mapeo de pares clave-valor, donde cada clave está asociada a un valor. Puede contener tipos de datos iguales o diferentes, no está ordenado y es mutable.\n\nclases = {\n    \"Analisis\": 10,\n    \"Algebra\": 25,\n    \"Fundamentos\": 30,\n    \"Discretas\": 14,\n    \"Multivariable\": 27,\n    \"Etica\": 35\n}\n\nprint(clases,\"\\n\")\nprint(clases.keys(),\"\\n\")\nprint(clases.values(),\"\\n\")\nprint(clases.items(),\"\\n\")\n\n{'Analisis': 10, 'Algebra': 25, 'Fundamentos': 30, 'Discretas': 14, 'Multivariable': 27, 'Etica': 35} \n\ndict_keys(['Analisis', 'Algebra', 'Fundamentos', 'Discretas', 'Multivariable', 'Etica']) \n\ndict_values([10, 25, 30, 14, 27, 35]) \n\ndict_items([('Analisis', 10), ('Algebra', 25), ('Fundamentos', 30), ('Discretas', 14), ('Multivariable', 27), ('Etica', 35)]) \n\n\n\n\nMetodos para diccionarios\n\n\nAgregar un elemento\nPara agregar un nuevo par de valores clave o actualizar uno existente en un diccionario de Python, puede usar el operador [ ] e ingresar la clave para actualizar o agregar y seguirlo con un = y el valor.\n\nupdate ( ): Función dedicada para agregar o actualizar un par de valores. Toma otro diccionario como argumento, lista o tupla que representa los pares de valores clave.\nsetdefault ( ): Sirve para agregar un nuevo elemento a nuestro diccionario.\npop ( ): Este método remueve específicamente una clave de diccionario y devuelve su valor correspondiente. Si no lo encuentra, devuelve error.\npopitem ( ): Este método remueve y devuelve algún par (clave, valor) del diccionario como una 2 tuplas. Lanza una excepción KeyError si el diccionario esta vació.\nget ( ): Recibe como parámetro una clave, devuelve el valor de la clave. Si no lo encuentra, devuelve un objeto none.\ncopy ( ): Retorna una copia del diccionario original.\nclear ( ): Elimina todos los ítems del diccionario dejándolo vacío.\nzip ( ): Recibe como parámetro dos elementos iterables, ya sea una cadena, una lista o una tupla. Ambos parámetros deben tener el mismo número de elementos. Se devolverá un diccionario relacionando el elemento i-esimo de cada uno de los iterables.\n\n\nclases = {\n    \"Analisis\": 10,\n    \"Algebra\": 25,\n    \"Fundamentos\": 30,\n    \"Discretas\": 14,\n    \"Multivariable\": 27,\n    \"Etica\": 35\n}\n\n# Agregar un elemento\n\n# Eliminar un elemento\n\n#Zip\n\ndic = dict(zip('abcd',[1,2,3,4]))\nprint(dic)\n\n{'a': 1, 'b': 2, 'c': 3, 'd': 4}\n\n\n\n\nIterando en diccionarios\n\n# Imprime los key del diccionario\nfor key in clases:\n    print(key)\n\nAnalisis\nAlgebra\nFundamentos\nDiscretas\nMultivariable\nEtica\n\n\n\nprint(\"Metodo 1 \\n\")\n# Imprime los value del diccionario\nfor key in clases:\n    print(clases[key])\n\nprint(\"\")\nprint(\"Metodo 2 \\n\")\n# Otro metodo\nfor value in clases.values():\n    print(value)\n\nMetodo 1 \n\n10\n25\n30\n14\n27\n35\n\nMetodo 2 \n\n10\n25\n30\n14\n27\n35\n\n\n\n# Imprime los key y value del diccionario\nfor x, y in clases.items():\n    print(x, y)\n\nAnalisis 10\nAlgebra 25\nFundamentos 30\nDiscretas 14\nMultivariable 27\nEtica 35\n\n\n\n# Diccionario con lista\n\ngrocery_items = {\"eggs\": [3.99, 4.99, 5.50],\n                 \"banana\": 1.49,\n                 \"cheese\": 4.5,\n                 \"eggplant\": 2.5,\n                \"bread\": 3.99}\n\ns = grocery_items[\"eggs\"]\nprint(s)\ns = grocery_items[\"eggs\"][0]\nprint(s)\n\n[3.99, 4.99, 5.5]\n3.99"
  },
  {
    "objectID": "Python - Parte 3.html#excepciones",
    "href": "Python - Parte 3.html#excepciones",
    "title": "clases",
    "section": "5. Excepciones",
    "text": "5. Excepciones\nLas excepciones en Python son una herramienta muy potente que la gran mayoría de lenguajes de programación modernos tienen. Se trata de una forma de controlar el comportamiento de un programa cuando se produce un error.\nImaginemos ahora que por cualquier motivo se quieren dividir nos variables (a/b), y que por ejemplo b tiene el valor 0. Si intentamos hacer la división entre cero, este programa dará un error y su ejecución terminará de manera abrupta.\n\na = 4; b = 0\nprint(a/b)\n\nZeroDivisionError: division by zero\n\n\nUna primera aproximación al control de exepciones podria ser la siguiente:\n\na = 5\nb = 0\n# A través de esta comprobación prevenimos que se divida entre cero.\nif b!=0:\n    print(a/b)\nelse:\n    print(\"No se puede dividir!\")\n\nNo se puede dividir!\n\n\nSin embargo, en Python puedes usar los bloques try y except para manejar estos errores como excepciones.\ntry:\n    # Codigo a ejecutar\n    # Pero podria haber errores en este bloque\n    \nexcept <tipo de error>:\n    # Haz esto para manejar la excepcion\n    # El bloque except se ejecutara si el bloque try lanza un error\n    \nelse:\n    # Esto se ejecutara si el bloque try se ejecuta sin errores\n   \nfinally:\n    # Este bloque se ejecutara siempre\n\nEl bloque try es el bloque con las sentencias que quieres ejecutar. Sin embargo, podrían llegar a haber errores de ejecución y el bloque se dejará de ejecutarse.\nEl bloque except se ejecutará cuando el bloque try falle debido a un error. Este bloque contiene sentencias que generalmente nos dan un contexto de lo que salió mal en el bloque try. Siempre se debe mencionar el tipo de error que se espera, como una excepción dentro del bloque except en <tipo de error> ya que de esta manera se identifica el tipo de error que podria ocurrir.\nEl bloque else se ejecutará solo si el bloque try se ejecuta sin errores.\nEl bloque finally siempre es ejecutado sin importar que pase en los otros bloques, esto puede ser útil cuando quieras liberar recursos después de la ejecución de un bloque de código.\n\n\nNota: Los bloques else y finally son opcionales.\n\nEl ejemplo anterior, utilizando estos bloques quedaria de la siguiente manera:\n\na = 5; b = 0\ntry:\n    c = a/b\nexcept ZeroDivisionError:\n    print(\"No se ha podido realizar la división\")\n\nNo se ha podido realizar la división"
  },
  {
    "objectID": "Python - Parte 3.html#lectura-de-archivos",
    "href": "Python - Parte 3.html#lectura-de-archivos",
    "title": "clases",
    "section": "6. Lectura de archivos",
    "text": "6. Lectura de archivos\nMuchas veces necesitamos que nuestros cálculos sean escritos en un archivo externo y no solamente escritos en la consola. Para ello usamos Python file.\n\n\n\n\n\n\n\nArgumento\nDescripción\n\n\n\n\nr\nTexto, leer solamente\n\n\nw\nTexto, escribir ( si existe un archivo con el mismo nombre este lo sobreescribe)\n\n\na\nTexto, adjuntar el texto al archivo ya existente\n\n\nr+\nTexto, leer y escribir\n\n\nrb\nBinario, leer solamente\n\n\nwb\nBinario, escribir ( si existe un archivo con el mismo nombre este lo sobreescribe)\n\n\nab\nBinario, adjuntar el texto al archivo ya existente\n\n\nrb+\nBinario leer y escribir\n\n\n\n\nReferencias:\nhttps://www.freecodecamp.org/espanol/news/sentencias-try-y-except-de-python-como-menejar-excepciones-en-python/ https://www.w3schools.com/python/python_try_except.asp"
  },
  {
    "objectID": "Python_Parte_1.html#entrada-y-salida",
    "href": "Python_Parte_1.html#entrada-y-salida",
    "title": "clases",
    "section": "2. Entrada y salida",
    "text": "2. Entrada y salida\nLos programas escritos en Python y los entornos de ejecución (como Google Colab) permiten al usuario interactuar de formas distintas. El usuario introduce información en forma de archivos, datos en la nube, o acciones de periféricos como el teclado y ratón, y los entornos de ejecución ejecutan el programa de Python. En consecuencia, le devuelven al usuario una respuesta en forma de texto, imagen o contenidos interactivos complejos. A continuación, conocera las funciones de entrada y salida de texto. Las más comunes y más útiles en los primeros pasos del aprendizaje del lenguaje son las funciones input y print.\nCuando se ejecuta input() la consola de Python espera que se le entregue texto, que puede escribir con su teclado o pegar del portapapeles, para luego hacer algo con este, como almacenarlo en una variable. Por otro lado, print() escribirá en consola texto que este almacenado previamente.\n\nnombre = input('Hola. ¿Cómo te llamas?\\n')\n\nHola. ¿Cómo te llamas?\nisa\n\n\n\nprint(\"¿Cómo se llama?\")\nnombre = input()\nprint(f\"Me alegro de conocerle, {nombre}\")\n\nNota: De forma predeterminada, la función input() siempre que lee algún dato, lo retorna como un string, incluso aunque sea un número válido y por ejemplo, si intentamos hacer operaciones, se producirá un error.\n\ncantidad = input(\"Dígame una cantidad en pesetas: \")\nprint(f\"{cantidad} pesetas son {round(cantidad / 166.386, 2)} euros\")\n\nPara evitar lo mencionado anteriormente, se debe convertir el dato a número (float o int) según lo que se requiera en el programa. Veamos entonces cómo leer y convertir los números de la entrada en Python.\nEjemplo: Si se quiere que Python interprete la entrada como un número entero, se debe utilizar la función int() de la siguiente manera:\n\ncantidad = int(input(\"Dígame una cantidad en pesetas: \"))\nprint(f\"{cantidad} pesetas son {round(cantidad / 166.386, 2)} euros\")\n\nEjemplo: Modifique el código anterior de tal manera que Python interprete la entrada como un float e imprima el valor con un redondeo de 3 dígitos."
  },
  {
    "objectID": "Python_Parte_1.html#tipos-de-dato-y-operadores",
    "href": "Python_Parte_1.html#tipos-de-dato-y-operadores",
    "title": "clases",
    "section": "3. Tipos de dato y operadores",
    "text": "3. Tipos de dato y operadores\n\nEl tipo de un dato es un atributo que determina qué operaciones se pueden realizar y qué valores puede tomar. Estos pueden ser números, listas, texto, entre otros. En Python, los tipos de dato no son definidos explícitamente, pero siempre están presentes en las variables que declaramos y es necesario tenerlos en cuenta. En particular, el tipo de dato define las operaciones válidas entre datos del mismo tipo. Estas operaciones están definidas con el uso de símbolos llamados operadores.\nPara conocer el tipo de dato de una variable, se usa la función type."
  },
  {
    "objectID": "Python_Parte_1.html#cadenas-de-texto",
    "href": "Python_Parte_1.html#cadenas-de-texto",
    "title": "clases",
    "section": "### 3.1. Cadenas de texto",
    "text": "### 3.1. Cadenas de texto\nUn tipo de dato muy importante es el de las cadenas de texto. Estas cadenas permiten almacenar en un mismo dato texto con cualquier cantidad de caracteres. Para definir una cadena de texto, se rodea el texto con comillas simples ' o comillas dobles \".\n\n'cadena con comilla simple'\n\n\n\"cadena con comillas dobles\"\n\nLas cadenas se pueden almacenar en variables, así:\n\nc = ' ¡Pontificia Universidad Javeriana Cali! '\n\n\nprint(c)\n\nAlgunos operadores de los usados para valores numéricos también sirven al operar con strings pero con utilidad distinta:\n\nConcatenación +.\nRepetición *.\nFormato %.\n\n\nConcatenación\n\n\nRepetición\n\n\nFormato\nEste operador permite reemplazar los marcadores de posición (%_) dentro de la string con la o las variables que se encuentren después del operador (%).\n\ntipo_calculo = \"raíz cuadrada de dos\"\nvalor = 2**0.5\nprint (\"el resultado de %s es %f\" % (tipo_calculo, valor))\n\nel resultado de raíz cuadrada de dos es 1.414214\n\n\nLas cadenas, como objetos que son, nos proporcionan métodos que nos facilitan su manipulación. Por ejemplo, siendo s una variable con un string:\n\ns.lower() : Retorna la cadena con todos los caracteres alfabéticos en minúscula.\ns.upper() : Retorna la cadena con todos los caracteres alfabéticos en mayúscula.\ns.replace(a, b) : Reemplaza las subcadenas iguales a la cadena a con el valor de la cadena b.\ns.strip() : Retorna la cadena con todos los espacios en blanco al principio y al final removidos.\ns.islower() : Determina si la cadena está compuesta solo por caracteres en mayúscula.\ns.isupper() : Determina si la cadena está compuesta solo por caracteres en mayúscula.\ns.isdigit() : Determina si la cadena está compuesta solo por dígitos del 0 al 9.\ns.isalpha() : Determina si la cadena está compuesta solo por caracteres alfabéticos.\n\nCada uno de los caracteres de una cadena (incluidos los espacios) tiene asignado un índice. Este indice nos permite seleccionar su carácter asociado haciendo referencia a él entre corchetes ([ ])\n\n\n\nimage.png\n\n\n\n\n3.2. Valores y operadores numéricos\n\nEn Python, los valores numéricos pueden ser de tres formas:\n\nNúmeros enteros. (int)\nNúmeros decimales. (float)\nNúmeros complejos. (complex)\n\n\na = 10            #int\nprint(a)\nprint(type(a))\n\n\na = -1089         #int - Se pueden escribir números negativos con el símbolo ‘-’\nprint(a)\nprint(type(a))\n\n\na = 1e100         #float - Esta sintaxis representa notación científica.\nprint(a)\nprint(type(a))\n\n1e+100\n<class 'float'>\n\n\n\na = 1 + 0.2j      #complex\nprint(a)\nprint(type(a))\n\n(1+0.2j)\n<class 'complex'>\n\n\nComo obtener la parte real e imaginaria de un numero complejo:\n\n(2.0+8.0j).real\n\n2.0\n\n\n\n(4.0+5.3j).imag\n\n5.3\n\n\nExisten varios operadores matemáticos para estos valores numéricos. Estos son:\n\n\n\nSimbolos\nOperaciones\n\n\n\n\n+\nsuma\n\n\n*\nMultiplicación\n\n\n/\nDivisión de numeros flotantes\n\n\n//\nDivisión de números enteros\n\n\n%\nMódulo\n\n\n**\nExponencial"
  },
  {
    "objectID": "Python_Parte_1.html#operados-logicos",
    "href": "Python_Parte_1.html#operados-logicos",
    "title": "clases",
    "section": "Operados logicos",
    "text": "Operados logicos\nOtro tipo de dato importante es el booleano, que representa un valor lógico de verdad. Puede tomar únicamente estos dos valores:\n\nVerdadero: True\nFalso: False\n\nEn Python, a diferencia de otros lenguajes de programación, las primitivas lógicas son escritas con la primera letra en mayúscula.\nAdemás de con el uso de las dos primitivas lógicas (True y False), se pueden obtener valores lógicos con la evaluación de expresiones con operadores relacionales. Los cuales se encuentran a continuación:\n\n\n\nSimbolos\nOperaciones\n\n\n\n\n==\nIgual\n\n\n!=\nDiferente\n\n\n<\nMenor que\n\n\n<=\nMenor igual que\n\n\n\\(>\\)\nMayor que\n\n\n\\(>=\\)\nMayor e igual que\n\n\n\n\nprint(-10  >   4.0)  # Mayor que.   \n\nFalse\n\n\n\nprint(-10  !=  4.0)  # Distinto que.\n\nTrue\n\n\n¿Puedo utilizar los operadores lógicos con string?\nPara evaluar más de una condición simultáneamente, se utilizan operadores lógicos. Estos son:\n\nAND lógico. and\nOR lógico. or\nNOT. negación. not\n\nEjemplo\nAdemás de estos operadores, se puede usar el operador is, que valida la identidad de un objeto. Para entender esto, tenemos que por su parte el operador == valida la igualdad de contenido de un objeto, mientras que el operador is valida si dos objetos, además de ser iguales en contenido, contienen la misma referencia en memoria, es decir, valida si son el mismo objeto. Si los valores son primitivas numéricas o lógicas el operador is retornará True.\n\n# Operador is\n\nprint('Operador is')\na = 1.0\nb = 1\n\nprint(a is b) # No tienen el mismo tipo de dato y por lo tanto son objetos distintos.\nprint(a == b) # Contienen el mismo valor al verificar su igualdad.\n\nOperador is\nFalse\nTrue"
  },
  {
    "objectID": "Python_Parte_2.html#condicionales-if-elif-y-else",
    "href": "Python_Parte_2.html#condicionales-if-elif-y-else",
    "title": "clases",
    "section": "1. Condicionales if, elif y else",
    "text": "1. Condicionales if, elif y else\n\nLas estructuras de control de flujo condicionales, permiten ejecutar bloques de código específicos según el valor de algunos datos. Se definen mediante el uso de tres palabras claves reservadas, del lenguaje: if (si), elif (sino, si) y else (sino).\nif test expression:\n    Body of if\nelif test expression:\n    Body of elif\nelse: \n    Body of else\nSi la condición que sigue a la palabra clave if se evalúa como verdadera , el bloque de código se ejecutará. Opcionalmente, puedes agregar una respuesta else la cual se ejecutará si la condición es false. Sin embargo, si se desea evaluar múltiples condiciones se usara la sentencia elif.\n\nEjemplo:\nTomemos un ejemplo de cómo encontrar un número que sea par y también mayor que 10\n\n'''En este programa, vamos a mirar si dado un numero \nes positivo, negativo o cero, con su respectivo mensaje '''\n\nnum = 3.4\n\nif num > 0:\n    print(\"Numero positivo\")\nelif num == 0:\n    print(\"Cero\")\nelse:\n    print(\"Numero negativo\")\n\nNumero positivo\n\n\n\n\nEjercicio 1\nEscribir un programa que almacene la cadena de caracteres contraseña en una variable, pregunte al usuario por la contraseña e imprima por pantalla si la contraseña introducida por el usuario coincide con la guardada en la variable sin tener en cuenta mayúsculas y minúsculas.\n\nLa clave debe estar en minuscula"
  },
  {
    "objectID": "Python_Parte_2.html#bucle-for",
    "href": "Python_Parte_2.html#bucle-for",
    "title": "clases",
    "section": "## 2. Bucle for",
    "text": "## 2. Bucle for\nLa estructura repetitiva For es aquella en la que el número de iteraciones se conoce por anticipado, y por ello no se precisa poner ninguna condición de salida para detener el bucle. En su lugar un contador cuenta el número de iteraciones fijas y se termina cuando llega al valor final previamente definido.\nSintaxis:\nfor <elem> in <iterable>:\n    <Código>\nAquí, elem es la variable que toma el valor del elemento dentro del iterador en cada paso del bucle. Este finaliza su ejecución cuando se recorren todos los elementos. Es frecuente usar el bucle for para iterar sobre los elementos de listas, tuplas o diccionarios.\n\nFunción range\nPara recorrer un conjunto de código un número específico de veces, podemos usar la función range(n), la cual devuelve una secuencia de números, comenzando desde 0 de forma predeterminada, se incrementa en 1 (de forma predeterminada) y termina cuando llega a n - 1.\n\nfor x in range(6):\n  print(x)\n\n0\n1\n2\n3\n4\n5\n\n\nLa función range(n) por defecto toma 0 como valor inicial, sin embargo, es posible especificar el valor inicial agregando un parámetro: range(2, 6) , lo que significa que toma valores del 2 al 6 (pero sin incluir el 6)\n\nfor x in range(2, 6):\n  print(x)\n\n2\n3\n4\n5\n\n\nLa función range(n) por defecto incrementa la secuencia en 1, sin embargo, agregando un tercer parámetro se puede especificar el valor del incremento: range(2, 30, 3 )\n\nfor x in range(1, 15, 3):\n  print(x)\n\n1\n4\n7\n10\n13\n\n\nCon for también puedo recorrer una cadena de caracteres:\n\ntexto=\"Isabella\"\nfor i in texto:\n    print(i)\n    #print(i,end=\"\")\n\nI\ns\na\nb\ne\nl\nl\na"
  },
  {
    "objectID": "Python_Parte_2.html#bucle-while",
    "href": "Python_Parte_2.html#bucle-while",
    "title": "clases",
    "section": "3. Bucle While",
    "text": "3. Bucle While\n\nEl ciclo while en Python se usa para iterar sobre un bloque de código siempre que la expresión de prueba (condición) sea verdadera. Generalmente usamos este ciclo cuando no sabemos la cantidad de veces que necesitamos iterar una sentencia.\nSintaxis:\nwhile test_expression:\n    Body of while\nEn el bucle while, primero se comprueba la expresión de prueba. El cuerpo del ciclo se ingresa solo si test_expression se evalúa como True. Después de una iteración, la expresión de prueba se verifica nuevamente. Este proceso continúa hasta que test_expression se evalue como False.\n\nx = 5\nwhile x > 0:\n    x -=1\n    print(x)\n\n4\n3\n2\n1\n0\n\n\n\nEjercicio 2\nUna empresa de ropa de la ciudad de Cali, va a lanzar una promoción sobre sus productos de la siguiente manera:\nSi el cliente compra menos de 5 productos, y si estos productos tienen un valor total menor a 100.000 COP, entonces se realizará un descuento del 10%. Si la compra es por un valor mayor o igual a 100.000 COP, el descuento es del 15% Si el cliente compra entre 5 a 10 productos, y el valor total de estos es mayor a 500.000 COP entonces se realizará un descuento del 20%, de lo contrario el descuento es del 18%. Si el cliente compra más de 10 productos y el valor total de la compra es menor a 1.000.000, el descuento será del 30%, en caso contrario el descuento es del 40%.\nEscriba un programa en Python que permita calcular el valor total a pagar del cliente teniendo en cuenta las condiciones dadas anteriormente,.\n\n\nEjercicio 3\nEscribir un programa en el que se pregunte al usuario por una frase y una letra, y muestre por pantalla el número de veces que aparece la letra en la frase.\n\n\nEjercicio 4\nRealice un programa que permita resolver la siguiente sumatoria:\n$ _{i=1}{n}(n3+n^2+3) $"
  },
  {
    "objectID": "Python_Parte_2.html#funciones",
    "href": "Python_Parte_2.html#funciones",
    "title": "clases",
    "section": "## 3. Funciones",
    "text": "## 3. Funciones\nLas funciones son bloques de código que se pueden reutilizar simplemente llamando a la función.\ndef identificador(param1, param2,..):\n    inst1\n    inst2\n    .\n    .\n    return valor\nPara definir una función en Python se utiliza la palabra reservada def. A continuación viene el nombre o identificador de la función que es el que se utiliza para invocarla dentro del código. Después del nombre hay que incluir los paréntesis y una lista opcional de parámetros. Por último, la definición de la función termina con dos puntos.\nTras los dos puntos se incluye el cuerpo de la función, en donde se encuentra el conjunto de instrucciones que se encapsulan en dicha función y finalmente, de manera opcional, se añade la instrucción con la palabra reservada return para devolver un resultado.\n\ndef new_function():\n  print(\"Hola, estoy en la función\")\n\nnew_function()\n\nHola, estoy en la función\n\n\nLas funciones permiten la reutilización de código es decir, que se evita escribir nuevamente secciones de código. Esto hace que el código sea más legible, facilita la depuración y limita los errores de escritura.\n\ndef func_name(nombre):\n  print(\" Hola,\", nombre)\n\n# Importante tener en cuenta la cantidad de argumentos que la función recibira\n\nfunc_name(\"Camilo\")\nfunc_name(\"Juan\")\nfunc_name(\"Maria\")\n\n Hola, Camilo\n Hola, Juan\n Hola, Maria\n\n\n\nEjercicio 5\nRealice un programa que pida n cantidad de numeros y por medio de un mensaje, muestre si el numero es par o no.\n\n\nReferencias:\nhttps://www.w3schools.com/PYTHON/"
  },
  {
    "objectID": "Python_Parte_3.html#listas",
    "href": "Python_Parte_3.html#listas",
    "title": "clases",
    "section": "## 4.1 Listas",
    "text": "## 4.1 Listas\nLas listas son el tipo de colección más común. Son estructuras de datos ordenadas con longitud variable. Esto quiere decir, que tras su declaración se pueden agregar o eliminar elementos específicos de su contenido. Además, estos elementos ocupan una posición definida secuencialmente, siendo el primer elemento el que ocupa la posición 0.\nExisten dos formas de declarar listas en Python: * Con llaves cuadradas.    Ejemplo: l = [] * Con la función list.      Ejemplo: l = list()\nEn el momento de su definición, se pueden definir valores por defecto, separados por coma.\n\nl = [1, 'Hola', 4.5]\nprint(l)\ntype(l)\n\n[1, 'Hola', 4.5]\n\n\nlist\n\n\nLas listas en Python son:\n\nHeterogéneas: Pueden estar conformadas por elementos de distintos tipo, incluyendo otras listas.\nMutables: Sus elementos pueden modificarse.\n\n\nl = [1, 2.5, [4, 5, 6, 7], \"Fin\"]\nprint(l)\ntype(l)\n\n[1, 2.5, [4, 5, 6, 7], 'Fin']\n\n\nlist\n\n\nLos elementos de una lista pueden accederse mediante su índice, siendo 0 el índice del primer elemento.\n\nprint(l[1])\n\nHola\n\n\nSe pueden realizar operaciones entre listas mediante algunos operadores. Es importante tener en cuenta los tipos de dato, pues símbolos como estos funcionan de manera distinta en relación al tipo de dato que manejan. Estos operadores básicos son:\n\nConcatenación +: Al aplicar este operador, se agregan los elementos de la segunda lista al final de la primera.\nRepetición *: Al aplicar este operador, se repiten los elementos la cantidad de veces expresada en el segundo operando.\n\n\nl_a = [1, 2, 3]\nl_b = ['a', 'b', 'c']\n\n\n# Concatenar\n\n\n# Repetición\n\n\nAlgunos comandos de la lista de metodos:\n\n\n\n\n\n\n\nMétodos\nDescripción\n\n\n\n\nappend(elemento)\nagregar elemento al final de la lista\n\n\nextend(lis2)\nExtiende la lista con los elementos de la lista 2\n\n\nindex(element)\nDevuelve el índice más bajo de la lista que contiene el elemento.\n\n\ninsert(index,element)\nInserta un elemento para el indice index\n\n\npop(i)\nElimina y retorna el elemento en la posición i\n\n\nreverse(element)\nInvierte la lista de lugar\n\n\nremove(element)\nElimina la primera aparición del elemento de la lista\n\n\nsort()\nClasifica la lista en lugar\n\n\ncopy()\nRetorna la copia de la lista\n\n\ncount(element)\nRetorna el némero de elementos igual al elemento de la lista\n\n\n\n\n\nUtilizar los metodos:\n\n\nInterando listas\n\nlista = [\"manzana\", \"banana\", \"cereza\"]\nfor x in lista:\n  print(x)\n\nmanzana\nbanana\ncereza"
  },
  {
    "objectID": "Python_Parte_3.html#tuplas",
    "href": "Python_Parte_3.html#tuplas",
    "title": "clases",
    "section": "4.2 Tuplas",
    "text": "4.2 Tuplas\n\nSon similares a las listas, pero lo que las diferencia es que estas son inmutables, esto quiere decir que no puede modificarse de ninguna forma después de que sean creadas. Los elementos de tupla están ordenados y permiten valores duplicados. Las tuplas se pueden definir de dos formas:\n\ntupla = (1,2,3,4)\n\n# También de esta forma\n\ntupla = tuple((1, 2, 3, 4))\n\nPara acceder a un valor dada una posición se realiza igual que con las listas, se escribe el nombre de la tupla seguido de apertura de corchetes, posición que buscamos y cierre de corchetes.\n\ntupla = tuple((1,2,3, 'r'))\nprint(tupla[1])\n\n2\n\n\nSe pueden recorrer los elementos de una tupla con for:\n\nfor dato in tupla:\n    print(dato, end=\" \")\n\n1 2 3 r \n\n\n\nFunciones de las tuplas:\nLongitud de una tupla\n\ntup = (1,2,13,-50)\nlen(tup)\n\n4\n\n\nMáximo de una tupla\n\ntup = (1,2,13,-50)\nmax(tup)\n\n13\n\n\nMinimo de una tupla\n\ntup = (1,2,13,-50)\nmin(tup)\n\n-50"
  },
  {
    "objectID": "Python_Parte_3.html#set",
    "href": "Python_Parte_3.html#set",
    "title": "clases",
    "section": "## 4.3 Set",
    "text": "## 4.3 Set\nLos conjuntos se utilizan para almacenar varios elementos en una sola variable. Un conjunto es una colección desordenada , inmutable* y no indexada.\n\nNota: Los elementos establecidos no se pueden modificar, pero puede eliminar elementos y agregar elementos nuevos.\n\n\nvocales = {'a', 'e', 'i', 'o', 'u', 'a', 'a', 'o', 'e'}\nprint(vocales)\n\nDado que los conjuntos son colecciones desordenadas, en ellos no se guarda la posición en la que son insertados los elementos como ocurre en los tipos lista o tuplas. Es por ello que no se puede acceder a los elementos a través de un índice.\nSin embargo, haciendo uso de un bucle for se puede acceder y/o recorrer todos los elementos del conjunto.\n\nprint(vocales{2})\n\nSyntaxError: invalid syntax (Temp/ipykernel_1032/3960885320.py, line 3)\n\n\n\nfor e in vocales:\n    print(e)\n\nu\na\ne\ni\no\n\n\nMetodos para utilizar en conjuntos.\n\nAgregar elementos\nUna vez que se crea un conjunto, no puede cambiar sus elementos, pero puede agregar nuevos elementos. Para agregar un elemento a un conjunto, utilice el método add().\n\nconjunto = {\"manzana\", \"cereza\", \"fresa\"}\n\nconjunto.add(\"mango\")\n\nprint(conjunto)\n\n{'manzana', 'cereza', 'mango', 'fresa'}\n\n\n\n\nAgregar conjuntos\nPara agregar elementos de otro conjunto al conjunto actual, utilice el método update(), se puede tomar como argumento una lista, tupla, string, conjunto o cualquier objeto de tipo iterable.\n\nconjunto = {\"manzana\", \"cereza\", \"fresa\"}\nlista = [\"kiwi\", \"naranja\"]\n\nconjunto.update(lista)\n\nprint(conjunto)\n\n{'fresa', 'manzana', 'naranja', 'cereza', 'kiwi'}\n\n\n\nAlgunos comandos de la lista de metodos:\n\n\n\n\n\n\n\nMétodos\nDescripción\n\n\n\n\nadd()\nAñade un elemento\n\n\nclear()\nRemueve todos los elementos\n\n\ncopy()\nEntrega una copia del set\n\n\ndifference()\nEntrega un set conteniendo los miembros diferentes entre dos o más sets\n\n\ndifference_update()\nRemueve los elementos en este set que también se incluyen en otro set específico\n\n\ndiscard()\nElimina, si existe, el elemento del conjunto.\n\n\nintersection()\nEntrega un set, que es la intersección de otros dos sets\n\n\nintersec_update()\nRemueve los elementos en este set que no se encuentran presentes en otro set específico.\n\n\nisdisjoint()\nEntrega si dos sets tienen una intersección o no\n\n\nissubset()\nEntrega si otro set contiene este set o no\n\n\nissuperset()\nEntrega si este set contiene otro set o no\n\n\npop()\nObtiene y elimina un elemento de forma aleatoria del conjunto\n\n\nremove()\nElimina el elemento del conjunto. Si no existe lanza un error.\n\n\nsymmetric_difference()\nEntrega un set con la diferencia simétrica de dos sets\n\n\nunion()\nEntrega un set que contiene la unión de dos sets\n\n\nupdate()\nActualiza el set con la unión de éste y otros sets\n\n\n\n\n\n\nUnir dos conjuntos\nHay varias formas de unir dos o más conjuntos en Python.\nPuede usar el método union() que devuelve un nuevo conjunto que contiene todos los elementos de ambos conjuntos, o el método update() que inserta todos los elementos de un conjunto en otro:\n\nset1 = {\"a\", \"b\" , \"c\"}\nset2 = {1, 2, 3}\n\nset3 = set1.union(set2)\nprint(set3)\n\n{1, 2, 'a', 3, 'b', 'c'}\n\n\nEl método update() inserta los elementos en set2 en set1:\n\nset1 = {\"a\", \"b\" , \"c\"}\nset2 = {1, 2, 3}\n\nset1.update(set2)\nprint(set1)"
  },
  {
    "objectID": "Python_Parte_3.html#diccionarios",
    "href": "Python_Parte_3.html#diccionarios",
    "title": "clases",
    "section": "4.4 Diccionarios",
    "text": "4.4 Diccionarios\n\nUn diccionario de Python es una estructura de datos para almacenar grupos de objetos. Consiste en un mapeo de pares clave-valor, donde cada clave está asociada a un valor. Puede contener tipos de datos iguales o diferentes, no está ordenado y es mutable.\n\nclases = {\n    \"Analisis\": 10,\n    \"Algebra\": 25,\n    \"Fundamentos\": 30,\n    \"Discretas\": 14,\n    \"Multivariable\": 27,\n    \"Etica\": 35\n}\n\nprint(clases,\"\\n\")\nprint(clases.keys(),\"\\n\")\nprint(clases.values(),\"\\n\")\nprint(clases.items(),\"\\n\")\n\n{'Analisis': 10, 'Algebra': 25, 'Fundamentos': 30, 'Discretas': 14, 'Multivariable': 27, 'Etica': 35} \n\ndict_keys(['Analisis', 'Algebra', 'Fundamentos', 'Discretas', 'Multivariable', 'Etica']) \n\ndict_values([10, 25, 30, 14, 27, 35]) \n\ndict_items([('Analisis', 10), ('Algebra', 25), ('Fundamentos', 30), ('Discretas', 14), ('Multivariable', 27), ('Etica', 35)]) \n\n\n\n\nMetodos para diccionarios\n\n\nAgregar un elemento\nPara agregar un nuevo par de valores clave o actualizar uno existente en un diccionario de Python, puede usar el operador [ ] e ingresar la clave para actualizar o agregar y seguirlo con un = y el valor.\n\nupdate ( ): Función dedicada para agregar o actualizar un par de valores. Toma otro diccionario como argumento, lista o tupla que representa los pares de valores clave.\nsetdefault ( ): Sirve para agregar un nuevo elemento a nuestro diccionario.\npop ( ): Este método remueve específicamente una clave de diccionario y devuelve su valor correspondiente. Si no lo encuentra, devuelve error.\npopitem ( ): Este método remueve y devuelve algún par (clave, valor) del diccionario como una 2 tuplas. Lanza una excepción KeyError si el diccionario esta vació.\nget ( ): Recibe como parámetro una clave, devuelve el valor de la clave. Si no lo encuentra, devuelve un objeto none.\ncopy ( ): Retorna una copia del diccionario original.\nclear ( ): Elimina todos los ítems del diccionario dejándolo vacío.\nzip ( ): Recibe como parámetro dos elementos iterables, ya sea una cadena, una lista o una tupla. Ambos parámetros deben tener el mismo número de elementos. Se devolverá un diccionario relacionando el elemento i-esimo de cada uno de los iterables.\n\n\nclases = {\n    \"Analisis\": 10,\n    \"Algebra\": 25,\n    \"Fundamentos\": 30,\n    \"Discretas\": 14,\n    \"Multivariable\": 27,\n    \"Etica\": 35\n}\n\n# Agregar un elemento\n\n# Eliminar un elemento\n\n#Zip\n\ndic = dict(zip('abcd',[1,2,3,4]))\nprint(dic)\n\n{'a': 1, 'b': 2, 'c': 3, 'd': 4}\n\n\n\n\nIterando en diccionarios\n\n# Imprime los key del diccionario\nfor key in clases:\n    print(key)\n\nAnalisis\nAlgebra\nFundamentos\nDiscretas\nMultivariable\nEtica\n\n\n\nprint(\"Metodo 1 \\n\")\n# Imprime los value del diccionario\nfor key in clases:\n    print(clases[key])\n\nprint(\"\")\nprint(\"Metodo 2 \\n\")\n# Otro metodo\nfor value in clases.values():\n    print(value)\n\nMetodo 1 \n\n10\n25\n30\n14\n27\n35\n\nMetodo 2 \n\n10\n25\n30\n14\n27\n35\n\n\n\n# Imprime los key y value del diccionario\nfor x, y in clases.items():\n    print(x, y)\n\nAnalisis 10\nAlgebra 25\nFundamentos 30\nDiscretas 14\nMultivariable 27\nEtica 35\n\n\n\n# Diccionario con lista\n\ngrocery_items = {\"eggs\": [3.99, 4.99, 5.50],\n                 \"banana\": 1.49,\n                 \"cheese\": 4.5,\n                 \"eggplant\": 2.5,\n                \"bread\": 3.99}\n\ns = grocery_items[\"eggs\"]\nprint(s)\ns = grocery_items[\"eggs\"][0]\nprint(s)\n\n[3.99, 4.99, 5.5]\n3.99"
  },
  {
    "objectID": "Python_Parte_3.html#excepciones",
    "href": "Python_Parte_3.html#excepciones",
    "title": "clases",
    "section": "5. Excepciones",
    "text": "5. Excepciones\nLas excepciones en Python son una herramienta muy potente que la gran mayoría de lenguajes de programación modernos tienen. Se trata de una forma de controlar el comportamiento de un programa cuando se produce un error.\nImaginemos ahora que por cualquier motivo se quieren dividir nos variables (a/b), y que por ejemplo b tiene el valor 0. Si intentamos hacer la división entre cero, este programa dará un error y su ejecución terminará de manera abrupta.\n\na = 4; b = 0\nprint(a/b)\n\nZeroDivisionError: division by zero\n\n\nUna primera aproximación al control de exepciones podria ser la siguiente:\n\na = 5\nb = 0\n# A través de esta comprobación prevenimos que se divida entre cero.\nif b!=0:\n    print(a/b)\nelse:\n    print(\"No se puede dividir!\")\n\nNo se puede dividir!\n\n\nSin embargo, en Python puedes usar los bloques try y except para manejar estos errores como excepciones.\ntry:\n    # Codigo a ejecutar\n    # Pero podria haber errores en este bloque\n    \nexcept <tipo de error>:\n    # Haz esto para manejar la excepcion\n    # El bloque except se ejecutara si el bloque try lanza un error\n    \nelse:\n    # Esto se ejecutara si el bloque try se ejecuta sin errores\n   \nfinally:\n    # Este bloque se ejecutara siempre\n\nEl bloque try es el bloque con las sentencias que quieres ejecutar. Sin embargo, podrían llegar a haber errores de ejecución y el bloque se dejará de ejecutarse.\nEl bloque except se ejecutará cuando el bloque try falle debido a un error. Este bloque contiene sentencias que generalmente nos dan un contexto de lo que salió mal en el bloque try. Siempre se debe mencionar el tipo de error que se espera, como una excepción dentro del bloque except en <tipo de error> ya que de esta manera se identifica el tipo de error que podria ocurrir.\nEl bloque else se ejecutará solo si el bloque try se ejecuta sin errores.\nEl bloque finally siempre es ejecutado sin importar que pase en los otros bloques, esto puede ser útil cuando quieras liberar recursos después de la ejecución de un bloque de código.\n\n\nNota: Los bloques else y finally son opcionales.\n\nEl ejemplo anterior, utilizando estos bloques quedaria de la siguiente manera:\n\na = 5; b = 0\ntry:\n    c = a/b\nexcept ZeroDivisionError:\n    print(\"No se ha podido realizar la división\")\n\nNo se ha podido realizar la división"
  },
  {
    "objectID": "Python_Parte_3.html#lectura-de-archivos",
    "href": "Python_Parte_3.html#lectura-de-archivos",
    "title": "clases",
    "section": "6. Lectura de archivos",
    "text": "6. Lectura de archivos\nMuchas veces necesitamos que nuestros cálculos sean escritos en un archivo externo y no solamente escritos en la consola. Para ello usamos Python file.\n\n\n\n\n\n\n\nArgumento\nDescripción\n\n\n\n\nr\nTexto, leer solamente\n\n\nw\nTexto, escribir ( si existe un archivo con el mismo nombre este lo sobreescribe)\n\n\na\nTexto, adjuntar el texto al archivo ya existente\n\n\nr+\nTexto, leer y escribir\n\n\nrb\nBinario, leer solamente\n\n\nwb\nBinario, escribir ( si existe un archivo con el mismo nombre este lo sobreescribe)\n\n\nab\nBinario, adjuntar el texto al archivo ya existente\n\n\nrb+\nBinario leer y escribir\n\n\n\n\nReferencias:\nhttps://www.freecodecamp.org/espanol/news/sentencias-try-y-except-de-python-como-menejar-excepciones-en-python/ https://www.w3schools.com/python/python_try_except.asp"
  },
  {
    "objectID": "Python_Parte_4.html#leer-base-de-datos-con-numpy",
    "href": "Python_Parte_4.html#leer-base-de-datos-con-numpy",
    "title": "clases",
    "section": "Leer base de datos con numpy",
    "text": "Leer base de datos con numpy\nVamos a trabajarlo desde Spyder sin embargo, aquí se encuentra la sintaxis de la función que nos permite cargar base de datos:\nloadtxt(fname, dtype=float, comments='#', delimiter=None,\n            converters=None, skiprows=0, usecols=None, unpack=False,\n            ndmin=0, encoding='bytes', max_rows=None, *, like=None):\nTambien, se puede utilizar la libreria Pandas\npd.read_csv('data.csv', delimiter=' ')"
  },
  {
    "objectID": "Python_Parte_5.html#libreria-matplotlib",
    "href": "Python_Parte_5.html#libreria-matplotlib",
    "title": "clases",
    "section": "# Libreria Matplotlib",
    "text": "# Libreria Matplotlib\n \nMatplotlib es una biblioteca completa para crear visualizaciones estáticas, animadas e interactivas en Python\nPara poder usar Matplotlib primero debemos instalarlo ya que es modulo externo. Por ejemplo, si se esta trabajando Python en conda, se debe abrir la terminal (Anaconda Prompt) y escribir conda install matplotlib.\nEn la pagina principal de Matplotlib encontraras mas funciones para graficar. En el siguiente link, se encuentran un CheatSheets de esta libreria https://matplotlib.org/cheatsheets/cheatsheets.pdf\nUna vez instalado, la forma más común de importar esta librería en nuestro archivo de trabajo es utilizando el alias plt. También, se suele utilizar la libreria numpy para crear los vectores.\n\n# Importar las librerias necesarias\nimport matplotlib\nimport numpy as np"
  },
  {
    "objectID": "Python_Parte_5.html#colores",
    "href": "Python_Parte_5.html#colores",
    "title": "clases",
    "section": "Colores",
    "text": "Colores\n \nTomado de: https://matplotlib.org/stable/tutorials/colors/colors.html#sphx-glr-tutorials-colors-colors-py\n\nTipos de línea\n\n\n\nCódigo\nTipo de línea\n\n\n\n\n-\nSolida\n\n\n–\nA trozos\n\n\n:\nPunteada\n\n\n\n\n\nTipos de marcadores\n\n\n\nCódigo\nMarca\nDescripción\n\n\n\n\n\\(.\\)\n\\(.\\)\nPunto\n\n\nO\n\\(o\\)\nCirculo\n\n\n+\n\\(+\\)\nMas\n\n\nX\n\\(\\times\\)\nCruz\n\n\nD\n\\(\\diamond\\)\nCiamante\n\n\nS\n\\(\\square\\)\nCuadrado\n\n\n*\n\\(\\star\\)\nEstrella\n\n\n\n\n\nUbicación de la leyenda\n\n\n\nString\ninteger\n\n\n\n\n‘best’\n0\n\n\n‘upper rigth’\n1\n\n\n‘upper ledft’\n2\n\n\n‘lower left’\n3\n\n\n‘lowe right’\n4\n\n\n‘right’\n5\n\n\n‘center left’\n6\n\n\n‘center rigth’\n7\n\n\n‘lower center’\n8\n\n\n‘upper center’\n9\n\n\n‘center’\n10"
  },
  {
    "objectID": "Python_Parte_5.html#figura",
    "href": "Python_Parte_5.html#figura",
    "title": "clases",
    "section": "Figura",
    "text": "Figura\n\nfig = plt.figure()  # Crear figura vacia sin ejes\nfig, ax = plt.subplots()  # Figura con un solo eje\nfig, axs = plt.subplots(2, 3)  # Figura con una cuadrícula de 2x2\n\n<Figure size 432x288 with 0 Axes>"
  },
  {
    "objectID": "Python_Parte_5.html#grafico-sencillo",
    "href": "Python_Parte_5.html#grafico-sencillo",
    "title": "clases",
    "section": "Grafico sencillo",
    "text": "Grafico sencillo\nLa forma más sencilla de crear una Figura con Ejes es usando pyplot.subplots\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots()  # Crea una figura que contenga un solo eje.\nax.plot([1, 2, 3, 4], [1, 4, 2, 3]);  # Grafica datos en los ejes."
  },
  {
    "objectID": "Python_Parte_5.html#graficar-puntos",
    "href": "Python_Parte_5.html#graficar-puntos",
    "title": "clases",
    "section": "Graficar puntos",
    "text": "Graficar puntos\nUtilizamos la función scatter(x, y): Dibuja un diagrama de puntos con las coordenadas de la lista x en el eje X y las coordenadas de la lista y en el eje Y.\nUtilizando la función plt.savefig('---.png') podemos guardar el gráfico en formato png\n\n# Crear la figura y los ejes\nfig, ax = plt.subplots()\n# Dibujar puntos\nax.scatter(x = [1, 2, 3, 4, 5, 6, 7], y = [3, 2, 1, 4, 6, 2, 1], c=\"r\")\n# Guardar el gráfico en formato png\nplt.savefig('diagrama-dispersion.png')\n# Mostrar el gráfico\nplt.show()\n\n\n\n\nOtro ejemplo\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nN = 50\nx = np.random.rand(N)\ny = np.random.rand(N)\ncolors = np.random.rand(N)\narea = (30 * np.random.rand(N))**2  # 0 to 15 point radii\n\nplt.scatter(x, y, s=area, c=colors, alpha=0.5)\nplt.show()"
  },
  {
    "objectID": "Python_Parte_5.html#grafica-de-funciones",
    "href": "Python_Parte_5.html#grafica-de-funciones",
    "title": "clases",
    "section": "Grafica de funciones",
    "text": "Grafica de funciones\n\n#Crea el vecto x con 50 valores equidistantes\nx = np.linspace(0,20,50) \n# Crea el vector y\ny= np.sin(x)\n \nc = plt.plot(x, y, 'c-3', linewidth = 2, label=\"sen(x)\")\nplt.legend(loc=3)\n \n\n<matplotlib.legend.Legend at 0x7fe026c4e150>"
  },
  {
    "objectID": "Python_Parte_5.html#graficar-otra-función",
    "href": "Python_Parte_5.html#graficar-otra-función",
    "title": "clases",
    "section": "Graficar otra función",
    "text": "Graficar otra función\nEn esta grafica tenemos puntos y ademas, graficamos una función.\n\n#Crea el vecto x con 30 valores equidistantes\nx = np.linspace(0,20,30) \n# Crea el vector y\ny= np.array(x**0.5)\n\nplt.scatter(x,y,color=\"green\")\nc = plt.plot(x, y, '-', color=\"red\", linewidth = 2, label=\"x^0.5\")\n# Se ingresa la posición donde se quiere ubicar la leyenda de la grafica\nplt.legend(loc=4)\n\n \n\n<matplotlib.legend.Legend at 0x7fe0273877d0>"
  },
  {
    "objectID": "Python_Parte_5.html#estilos",
    "href": "Python_Parte_5.html#estilos",
    "title": "clases",
    "section": "Estilos",
    "text": "Estilos\nSe tienen dos metodos esenciales para trabajar con matplotlib.\n\nCrear explícitamente figuras y ejes, llamando metodos en ellos.\n\n\nx = np.linspace(0, 2, 100)  # Sample data.\n\n# Note that even in the OO-style, we use `.pyplot.figure` to create the Figure.\nfig, ax = plt.subplots(figsize=(5, 2.7))\nax.plot(x, x, label='linear')  # Plot some data on the axes.\nax.plot(x, x**2, label='quadratic')  # Plot more data on the axes...\nax.plot(x, x**3, label='cubic')  # ... and some more.\nax.set_xlabel('x label')  # Add an x-label to the axes.\nax.set_ylabel('y label')  # Add a y-label to the axes.\nax.set_title(\"Simple Plot\")  # Add a title to the axes.\nax.legend();  # Add a legend.\n\n\n\n\n\nConfiar en pyplot para crear y administrar automáticamente las figuras y los ejes, utilizando las funciones de pyplot para trazar.\n\n\nx = np.linspace(0, 2, 100)  # Sample data.\n\nplt.figure(figsize=(5, 2.7))\nplt.plot(x, x, label='linear')  # Plot some data on the (implicit) axes.\nplt.plot(x, x**2, label='quadratic')  # etc.\nplt.plot(x, x**3, label='cubic')\nplt.xlabel('x label')\nplt.ylabel('y label')\nplt.title(\"Simple Plot\")\nplt.legend();"
  },
  {
    "objectID": "Python_Parte_5.html#diagramas-de-areas",
    "href": "Python_Parte_5.html#diagramas-de-areas",
    "title": "clases",
    "section": "Diagramas de areas",
    "text": "Diagramas de areas\nfill_between(x, y): Dibuja el area bajo el polígono con los vértices dados por las coordenadas de la lista x en el eje X y las coordenadas de la lista y en el eje Y.\n\nfig, ax = plt.subplots()\nax.fill_between([1, 2, 3, 4], [1, 2, 0, 0.5])\nplt.show()\n\n\n\n\nPodemos modificar el color añadiendo otro parametro en la función fill_between(x, y, facecolor=\"Name_Color\"):\n\nfig, ax = plt.subplots()\nax.fill_between([1, 2, 3, 4], [1, 2, 0, 0.5], facecolor=\"r\")\nplt.show()"
  },
  {
    "objectID": "Python_Parte_5.html#anotar",
    "href": "Python_Parte_5.html#anotar",
    "title": "clases",
    "section": "Anotar",
    "text": "Anotar\n\nfig, ax = plt.subplots(figsize=(5, 2.7))\n\nt = np.arange(0.0, 5.0, 0.01)\ns = np.cos(2 * np.pi * t)\nline, = ax.plot(t, s, lw=2)\n\nax.annotate('local max', xy=(2, 1), xytext=(3, 1.5),\n            arrowprops=dict(facecolor='black', shrink=0.05))\n\nax.set_ylim(-2, 2);"
  },
  {
    "objectID": "Python_Parte_5.html#matplotlib-subplot",
    "href": "Python_Parte_5.html#matplotlib-subplot",
    "title": "clases",
    "section": "Matplotlib Subplot",
    "text": "Matplotlib Subplot\nSintaxis:\nsubplot(numRows, numCols, plotNum)\n\n* numRows = Número de filas\n* numCols = Número de columnas\n* plotNum = Número de gráfica\n\n#plot 1:\nx = np.array([0, 1, 2, 3])\ny = np.array([3, 8, 1, 10])\n\nplt.subplot(3, 1, 1)\nplt.plot(x,y)\nplt.title(\"Plot 1\")\n\n#plot 2:\nx = np.array([0, 1, 2, 3])\ny = np.array([10, 20, 30, 40])\n\nplt.subplot(3, 1, 3)\nplt.plot(x,y)\nplt.title(\"Plot 2\")\n\nplt.show()"
  },
  {
    "objectID": "Python_Parte_5.html#grafica-en-coordenadas-polares",
    "href": "Python_Parte_5.html#grafica-en-coordenadas-polares",
    "title": "clases",
    "section": "Grafica en coordenadas polares",
    "text": "Grafica en coordenadas polares\n\ntheta = np.linspace(0, 2.*np.pi, 1000)\na = 1.\nr = 2 * a * (1. + np.cos(theta))\nplt.polar(theta, r)\nplt.show()"
  },
  {
    "objectID": "Python_Parte_5.html#diagrama-de-barras",
    "href": "Python_Parte_5.html#diagrama-de-barras",
    "title": "clases",
    "section": "Diagrama de Barras",
    "text": "Diagrama de Barras\n\nx = np.array([\"A\", \"B\", \"C\", \"D\"])\ny = np.array([3, 8, 1, 10])\n\nplt.bar(x, y, color=\"c\")\n\n## Leyenda en el eje x\nplt.xlabel('Grupos')\n\n## Leyenda en el eje y\nplt.ylabel('Cantidad')\n \n## Título de Gráfica\nplt.title('Grafica')\n\nplt.show()"
  },
  {
    "objectID": "Python_Parte_5.html#diagrama-de-torta",
    "href": "Python_Parte_5.html#diagrama-de-torta",
    "title": "clases",
    "section": "Diagrama de torta",
    "text": "Diagrama de torta\n\ny = np.array([35, 25, 25, 15])\nmylabels = [\"Apples\", \"Bananas\", \"Cherries\", \"Dates\"]\n\nplt.pie(y, labels = mylabels)\nplt.show()"
  },
  {
    "objectID": "Terminado_Introduccion_a_Python_Parte_1.html#entrada-y-salida",
    "href": "Terminado_Introduccion_a_Python_Parte_1.html#entrada-y-salida",
    "title": "clases",
    "section": "2. Entrada y salida",
    "text": "2. Entrada y salida\nLos programas escritos en Python y los entornos de ejecución (como Google Colab) permiten al usuario interactuar de formas distintas. El usuario introduce información en forma de archivos, datos en la nube, o acciones de periféricos como el teclado y ratón, y los entornos de ejecución ejecutan el programa de Python. En consecuencia, le devuelven al usuario una respuesta en forma de texto, imagen o contenidos interactivos complejos. A continuación, conocera las funciones de entrada y salida de texto. Las más comunes y más útiles en los primeros pasos del aprendizaje del lenguaje son las funciones input y print.\nCuando se ejecuta input() la consola de Python espera que se le entregue texto, que puede escribir con su teclado o pegar del portapapeles, para luego hacer algo con este, como almacenarlo en una variable. Por otro lado, print() escribirá en consola texto que este almacenado previamente.\n\nnombre = input('Hola. ¿Cómo te llamas?\\n')\n\nHola. ¿Cómo te llamas?\nisa\n\n\n\nprint(\"¿Cómo se llama?\")\nnombre = input()\nprint(\"¿Cual es su edad?\")\nedad = input()\nprint(f\"Me alegro de conocerle, {nombre}\")\nprint(f\"Con {edad} años\")\n\n¿Cómo se llama?\nisa\n¿Cual es su edad?\n3\nMe alegro de conocerle, isa\nCon 3 años\n\n\nNota: De forma predeterminada, la función input() siempre que lee algún dato, lo retorna como un string, incluso aunque sea un número válido y por ejemplo, si intentamos hacer operaciones, se producirá un error.\n\ncantidad = input(\"Dígame una cantidad en pesetas: \")\nprint(f\"{cantidad} pesetas son {round(cantidad / 166.386, 2)} euros\")\n\nDígame una cantidad en pesetas: jm\n\n\nTypeError: ignored\n\n\nPara evitar lo mencionado anteriormente, se debe convertir el dato a número (float o int) según lo que se requiera en el programa. Veamos entonces cómo leer y convertir los números de la entrada en Python.\nEjemplo: Si se quiere que Python interprete la entrada como un número entero, se debe utilizar la función int() de la siguiente manera:\n\ncantidad = int(input(\"Dígame una cantidad en pesetas: \"))\nprint(f\"{cantidad} pesetas son {round(cantidad / 166.386, 2)} euros\")\n\nDígame una cantidad en pesetas: 40\n40 pesetas son 0.24 euros\n\n\nEjemplo: Modifique el código anterior de tal manera que Python interprete la entrada como un float e imprima el valor con un redondeo de 3 dígitos."
  },
  {
    "objectID": "Terminado_Introduccion_a_Python_Parte_1.html#tipos-de-dato-y-operadores",
    "href": "Terminado_Introduccion_a_Python_Parte_1.html#tipos-de-dato-y-operadores",
    "title": "clases",
    "section": "3. Tipos de dato y operadores",
    "text": "3. Tipos de dato y operadores\n\nEl tipo de un dato es un atributo que determina qué operaciones se pueden realizar y qué valores puede tomar. Estos pueden ser números, listas, texto, entre otros. En Python, los tipos de dato no son definidos explícitamente, pero siempre están presentes en las variables que declaramos y es necesario tenerlos en cuenta. En particular, el tipo de dato define las operaciones válidas entre datos del mismo tipo. Estas operaciones están definidas con el uso de símbolos llamados operadores.\nPara conocer el tipo de dato de una variable, se usa la función type.\n\nnum = 40\nprint(type(num))\nPersona = 3\n\n<class 'int'>"
  },
  {
    "objectID": "Terminado_Introduccion_a_Python_Parte_1.html#cadenas-de-texto",
    "href": "Terminado_Introduccion_a_Python_Parte_1.html#cadenas-de-texto",
    "title": "clases",
    "section": "### 3.1. Cadenas de texto",
    "text": "### 3.1. Cadenas de texto\nUn tipo de dato muy importante es el de las cadenas de texto. Estas cadenas permiten almacenar en un mismo dato texto con cualquier cantidad de caracteres. Para definir una cadena de texto, se rodea el texto con comillas simples ' o comillas dobles \".\n\n'cadena con comilla simple'\n\n'cadena con comilla simple'\n\n\n\n\"cadena con comillas dobles\"\n\n'cadena con comillas dobles'\n\n\nLas cadenas se pueden almacenar en variables, así:\n\nc = ' ¡Pontificia Universidad Javeriana Cali! '\n\n\nprint(c)\n\n ¡Pontificia Universidad Javeriana Cali! \n\n\nAlgunos operadores de los usados para valores numéricos también sirven al operar con strings pero con utilidad distinta:\n\nConcatenación +.\nRepetición *.\nFormato %.\n\n\nConcatenación\n\nc = ' ¡Pontificia Universidad Javeriana Cali! '\nname = \" Andres \"\nc + name\n\n' ¡Pontificia Universidad Javeriana Cali!  Andres '\n\n\n\n\nRepetición\n\nname * 3\n\n' Andres  Andres  Andres '\n\n\n\n\nFormato\nEste operador permite reemplazar los marcadores de posición (%_) dentro de la string con la o las variables que se encuentren después del operador (%).\n\ntipo_calculo = \"raíz cuadrada de dos\"\nvalor = 2**0.5\nprint (\"el resultado de %s es %f\" % (tipo_calculo, valor))\n\nel resultado de raíz cuadrada de dos es 1.414214\n\n\nLas cadenas, como objetos que son, nos proporcionan métodos que nos facilitan su manipulación. Por ejemplo, siendo s una variable con un string:\n\ns.lower() : Retorna la cadena con todos los caracteres alfabéticos en minúscula.\ns.upper() : Retorna la cadena con todos los caracteres alfabéticos en mayúscula.\ns.replace(a, b) : Reemplaza las subcadenas iguales a la cadena a con el valor de la cadena b.\ns.strip() : Retorna la cadena con todos los espacios en blanco al principio y al final removidos.\ns.islower() : Determina si la cadena está compuesta solo por caracteres en mayúscula.\ns.isupper() : Determina si la cadena está compuesta solo por caracteres en mayúscula.\ns.isdigit() : Determina si la cadena está compuesta solo por dígitos del 0 al 9.\ns.isalpha() : Determina si la cadena está compuesta solo por caracteres alfabéticos.\n\n\nc = ' ¡Pontificia Universidad Javeriana Cali! '\nc.lower()\nc.upper()\nc.replace('a','x')\n#c.strip()\n#c = c.upper()\n#print(c)\n\n' ¡Pontificix Universidxd Jxverixnx Cxli! '\n\n\nCada uno de los caracteres de una cadena (incluidos los espacios) tiene asignado un índice. Este indice nos permite seleccionar su carácter asociado haciendo referencia a él entre corchetes ([ ])\n\n\n\nimage.png\n\n\n\nc = '¡Pontificia Universidad Javeriana Cali!'\nc[:3]\nc[-1]\n\n'!'\n\n\n\n\n3.2. Valores y operadores numéricos\n\nEn Python, los valores numéricos pueden ser de tres formas:\n\nNúmeros enteros. (int)\nNúmeros decimales. (float)\nNúmeros complejos. (complex)\n\n\na = 10            #int\nprint(a)\nprint(type(a))\n\n10\n<class 'int'>\n\n\n\na = -1089         #int - Se pueden escribir números negativos con el símbolo ‘-’\nprint(a)\nprint(type(a))\n\n-1089\n<class 'int'>\n\n\n\na = 1e100         #float - Esta sintaxis representa notación científica.\nprint(a)\nprint(type(a))\n\n1e+100\n<class 'float'>\n\n\n\na = 1 + 0.2j      #complex\nprint(a)\nprint(type(a))\n\n(1+0.2j)\n<class 'complex'>\n\n\nComo obtener la parte real e imaginaria de un numero complejo:\n\n(2.0+8.0j).real\n\n2.0\n\n\n\n(4.0+5.3j).imag\n\n5.3\n\n\n\na = 2.0+8.0j\nb = 4.0+5.3j\n(a+b).imag\n\n13.3\n\n\nExisten varios operadores matemáticos para estos valores numéricos. Estos son:\n\n\n\nSimbolos\nOperaciones\n\n\n\n\n+\nSuma\n\n\n*\nMultiplicación\n\n\n/\nDivisión de numeros flotantes\n\n\n//\nDivisión de números enteros\n\n\n%\nMódulo\n\n\n**\nExponencial\n\n\n\n\n3**2\n\n9\n\n\n\n12%2\n\n0"
  },
  {
    "objectID": "Terminado_Introduccion_a_Python_Parte_1.html#operados-logicos",
    "href": "Terminado_Introduccion_a_Python_Parte_1.html#operados-logicos",
    "title": "clases",
    "section": "Operados logicos",
    "text": "Operados logicos\nOtro tipo de dato importante es el booleano, que representa un valor lógico de verdad. Puede tomar únicamente estos dos valores:\n\nVerdadero: True\nFalso: False\n\nEn Python, a diferencia de otros lenguajes de programación, las primitivas lógicas son escritas con la primera letra en mayúscula.\nAdemás de con el uso de las dos primitivas lógicas (True y False), se pueden obtener valores lógicos con la evaluación de expresiones con operadores relacionales. Los cuales se encuentran a continuación:\n\n\n\nSimbolos\nOperaciones\n\n\n\n\n==\nIgual\n\n\n!=\nDiferente\n\n\n<\nMenor que\n\n\n<=\nMenor igual que\n\n\n\\(>\\)\nMayor que\n\n\n\\(>=\\)\nMayor e igual que\n\n\n\n\nprint(-10  >   4.0)  # Mayor que.   \n\nFalse\n\n\n\nprint(-10  !=  4.0)  # Distinto que.\n\nTrue\n\n\n\na = 'Michele'\nb = 'Santi'\na < b\nb != a\n\nTrue\n\n\n¿Puedo utilizar los operadores lógicos con string?\nPara evaluar más de una condición simultáneamente, se utilizan operadores lógicos. Estos son:\n\nAND lógico. and\nOR lógico. or\nNOT. negación. not\n\nEjemplo\n\na = True\nb = False \nc = True\n\nprint(a or b)\n\nTrue\n\n\nAdemás de estos operadores, se puede usar el operador is, que valida la identidad de un objeto. Para entender esto, tenemos que por su parte el operador == valida la igualdad de contenido de un objeto, mientras que el operador is valida si dos objetos, además de ser iguales en contenido, contienen la misma referencia en memoria, es decir, valida si son el mismo objeto. Si los valores son primitivas numéricas o lógicas el operador is retornará True.\n\n# Operador is\n\nprint('Operador is')\na = 1.0\nb = 1\n\nprint(a is b) # No tienen el mismo tipo de dato y por lo tanto son objetos distintos.\nprint(a == b) # Contienen el mismo valor al verificar su igualdad.\n\nOperador is\nFalse\nTrue"
  },
  {
    "objectID": "Intalacion.html",
    "href": "Intalacion.html",
    "title": "Instalación Phyton",
    "section": "",
    "text": "Intalación de python\nAntes de comenzar debemos instalar python en nuestro equipo\n\nVamos a la pagina oficial de anaconda y descargamos ultima vesrio de este software https://www.anaconda.com/products/individual\nInstalamos el software en nuestro equipo\nAbrimos una terminal y vamosa crear un entorno virtual para trabajar con python\n\n\nconda create -n python3 python=3.8\nAhora vamos a entrar al entornode trabajo\nconda activate python3\nNote que el nombre del entorno de trabajo aparece entre parentesis en la terminal. Ahora vamos a instalar jupyter notebook\nconda install -c conda-forge notebook\npara instalar la libreria numpy\nconda install -c anaconda numpy\nDesde la terminal podemos ejecutar jupyter notebook\njupyter notebook\nEsto nos abrira una ventana en el navegador donde podemos crear un nuevo notebook\n\n\n\njupyter"
  },
  {
    "objectID": "Python_numpy.html",
    "href": "Python_numpy.html",
    "title": "Errores",
    "section": "",
    "text": "import numpy as np\n\na=np.matrix([[1, 2], [3, 4]])\na.shape\n\n(2, 2)\n\n\n\n# otra forma de imprimir una matriz\na = np.matrix('1 2; 3 4')\na\n\nmatrix([[1, 2],\n        [3, 4]])\n\n\n\n#tomar la primera fila de la matriz\nprint(a[0])\n\n[[1 2]]\n\n\n\nprint(a[0][:])\n\n[[1 2]]\n\n\n\nprint(a[:,1])\n\n[[2]\n [4]]\n\n\n\n# 1st argument --> numbers ranging from 0 to 9, \n# 2nd argument, row = 2, col = 3\narray = np.random.randint(10, size=(5, 5))\nprint(array)\n\n[[7 6 5 8 4]\n [6 3 7 4 3]\n [7 8 9 0 1]\n [5 0 9 4 0]\n [0 2 2 1 6]]\n\n\n\narray[2:,:]\n\narray([[7, 8, 9, 0, 1],\n       [5, 0, 9, 4, 0],\n       [0, 2, 2, 1, 6]])\n\n\n\n# escoger una submatriz de una matriz array\n\narray[1:3, 1:3 ]\n\narray([[8, 7],\n       [0, 5]])\n\n\n\n# escojemos las columnas impares y filas pares\n\narray[::2, 1::2]\n\narray([[6, 8],\n       [8, 0],\n       [2, 1]])\n\n\n\n# multiplicar dos matrices \n\nA=np.array([[1,2],[3,4]])\nB=np.array([[5,6],[7,8]])\nA@B\n\narray([[19, 22],\n       [43, 50]])\n\n\n\n\n# Vector fila\nvector_fila = np.array([1, 2, 3, 4, 5])\n\n# Redimensionar a un vector columna\nvector_columna = vector_fila[:, np.newaxis]\n\nprint(vector_columna)\nvector_columna.\n\n[[1]\n [2]\n [3]\n [4]\n [5]]\n\n\n\n# Transpuesta de una matriz     A.T\nA.T\n\narray([[1, 3],\n       [2, 4]])\n\n\n\n# producto punto de dos vectores\na=np.array([1,2,3])\nb=np.array([4,5,6])\nprint(a.dot(b))\nprint(np.dot(a,b))\n\n32\n32\n\n\n\n# producto de un numero por un array\n5 * a\n\narray([ 5, 10, 15])\n\n\n\n# producto elemento a elemento\na*b\n\narray([ 4, 10, 18])\n\n\n\n# potenciacion de un array\n\na**2\n\narray([1, 4, 9])\n\n\n\nnp.sin(a)\n\narray([0.84147098, 0.90929743, 0.14112001])\n\n\n\n#crear una matriz de ceros \nA=np.zeros((3,3))\n# crear una matriz de unos\nB=np.ones((3,3))\n\n\nfrom PIL import Image\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef imagen_a_matriz(ruta_imagen):\n    # Abrir la imagen\n    imagen = Image.open(ruta_imagen)\n    # convertir a blanco y negro\n    imagen = imagen.convert(\"L\")\n    # Convertir la imagen a una matriz NumPy\n    matriz = np.array(imagen)\n\n    return matriz\n\n# Ruta de la imagen que quieres convertir a matriz\nruta_imagen = \"img.png\"\n\n# Llamar a la función para convertir la imagen a matriz\nmatriz_imagen = imagen_a_matriz(ruta_imagen)\n\n# Imprimir la matriz resultante\nprint(matriz_imagen)\nplt.imshow(matriz_imagen, cmap='gray') \n\n[[255 255 255 ... 255 255 255]\n [255 255 255 ... 255 255 255]\n [255 255 255 ... 255 255 255]\n ...\n [255 255 255 ... 255 255 255]\n [255 255 255 ... 255 255 255]\n [255 255 255 ... 255 255 255]]\n\n\n<matplotlib.image.AxesImage at 0x7fbcb89f0ad0>\n\n\n\n\n\n\ncual es la dimension de la matriz\nCrear una nueva matriz con solo los elementos pares de las filas y elementos impares de las columnas\nCrear una matriz con solo los elementos que muestren la nariz del animal"
  },
  {
    "objectID": "Python_numpy.html#si-la-aproximación-se-hace-mediante-redondeo-se-dice-que",
    "href": "Python_numpy.html#si-la-aproximación-se-hace-mediante-redondeo-se-dice-que",
    "title": "Errores",
    "section": "Si la aproximación se hace mediante redondeo, se dice que:",
    "text": "Si la aproximación se hace mediante redondeo, se dice que:\n\\(x_n\\) aproxima a \\(x\\) con un \\(k\\) dígitos decimales, si \\(k\\) es el mayor entero negativo tal que \\[e_n\\leq \\frac{1}{2}\\times 10^{-k}\\]\n\\(x_n\\) aproxima a \\(x\\) con un \\(k\\) cifras significativas, si \\(k\\) es el mayor entero negativo tal que \\[\\epsilon_n\\leq \\frac{10^{-k}}{2}\\]\n\nInstala la librería pandas matplotlib usando anaconda desde enviroments\nImporta la librería pandas\nimporta la librería matplotlib.pyplot\n\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Crear un DataFrame vacío con las columnas deseadas\ncolumnas = [\"iteracion\", \"valor\", \"error absoluto\", \"error relativo\"]\ndf = pd.DataFrame(columns=columnas)\n\n# Imprimir el DataFrame vacío\nprint(df)\n\nEmpty DataFrame\nColumns: [iteracion, valor, error absoluto, error relativo]\nIndex: []\n\n\n\nfor i in range(1,10):\n    df = df.append({\"iteracion\": i, \"valor\": 2-1/i, \"error absoluto\": np.abs(1/i), \"error relativo\": np.abs(2/i)}, ignore_index=True)\n\n# Imprimir el DataFrame actualizado\nprint(df)\n\n    iteracion     valor  error absoluto  error relativo\n0         1.0  0.000000        1.000000        0.010000\n1         2.0  0.500000        0.500000        0.010000\n2         3.0  0.666667        0.333333        0.010000\n3         4.0  0.750000        0.250000        0.010000\n4         5.0  0.800000        0.200000        0.010000\n5         6.0  0.833333        0.166667        0.010000\n6         7.0  0.857143        0.142857        0.010000\n7         8.0  0.875000        0.125000        0.010000\n8         9.0  0.888889        0.111111        0.010000\n9         1.0  1.000000        1.000000        2.000000\n10        2.0  1.500000        0.500000        1.000000\n11        3.0  1.666667        0.333333        0.666667\n12        4.0  1.750000        0.250000        0.500000\n13        5.0  1.800000        0.200000        0.400000\n14        6.0  1.833333        0.166667        0.333333\n15        7.0  1.857143        0.142857        0.285714\n16        8.0  1.875000        0.125000        0.250000\n17        9.0  1.888889        0.111111        0.222222\n\n\n/tmp/ipykernel_74250/117203946.py:2: FutureWarning: The frame.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.\n  df = df.append({\"iteracion\": i, \"valor\": 2-1/i, \"error absoluto\": np.abs(1/i), \"error relativo\": np.abs(2/i)}, ignore_index=True)\n/tmp/ipykernel_74250/117203946.py:2: FutureWarning: The frame.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.\n  df = df.append({\"iteracion\": i, \"valor\": 2-1/i, \"error absoluto\": np.abs(1/i), \"error relativo\": np.abs(2/i)}, ignore_index=True)\n/tmp/ipykernel_74250/117203946.py:2: FutureWarning: The frame.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.\n  df = df.append({\"iteracion\": i, \"valor\": 2-1/i, \"error absoluto\": np.abs(1/i), \"error relativo\": np.abs(2/i)}, ignore_index=True)\n/tmp/ipykernel_74250/117203946.py:2: FutureWarning: The frame.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.\n  df = df.append({\"iteracion\": i, \"valor\": 2-1/i, \"error absoluto\": np.abs(1/i), \"error relativo\": np.abs(2/i)}, ignore_index=True)\n/tmp/ipykernel_74250/117203946.py:2: FutureWarning: The frame.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.\n  df = df.append({\"iteracion\": i, \"valor\": 2-1/i, \"error absoluto\": np.abs(1/i), \"error relativo\": np.abs(2/i)}, ignore_index=True)\n/tmp/ipykernel_74250/117203946.py:2: FutureWarning: The frame.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.\n  df = df.append({\"iteracion\": i, \"valor\": 2-1/i, \"error absoluto\": np.abs(1/i), \"error relativo\": np.abs(2/i)}, ignore_index=True)\n/tmp/ipykernel_74250/117203946.py:2: FutureWarning: The frame.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.\n  df = df.append({\"iteracion\": i, \"valor\": 2-1/i, \"error absoluto\": np.abs(1/i), \"error relativo\": np.abs(2/i)}, ignore_index=True)\n/tmp/ipykernel_74250/117203946.py:2: FutureWarning: The frame.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.\n  df = df.append({\"iteracion\": i, \"valor\": 2-1/i, \"error absoluto\": np.abs(1/i), \"error relativo\": np.abs(2/i)}, ignore_index=True)\n/tmp/ipykernel_74250/117203946.py:2: FutureWarning: The frame.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.\n  df = df.append({\"iteracion\": i, \"valor\": 2-1/i, \"error absoluto\": np.abs(1/i), \"error relativo\": np.abs(2/i)}, ignore_index=True)\n\n\n\n# Graficar la columna \"Valor\"\nplt.plot(df['iteracion'], df['error absoluto'], marker='o',linestyle='none',  color='b')\n\n# Personalizar la gráfica\nplt.title('Gráfico del error relativo vs iteración')\nplt.xlabel('Iteración')\nplt.ylabel('Error absoluto')\nplt.grid(True)\n\n\n\n\n\ngenere una gráfica del error relativo.\n\nGenere un codigo para aproximar la función\n\\[e^5  =\\lim_{m\\to \\infty }S_m, \\text{ donde } S_m=\\sum_{n=0}^{m} \\frac{5^n}{n!}\\]\n\nmuestre las primeras 10 aproximaciones\nmuestre una gráfica del error absoluto y relativo de cada aproximación"
  },
  {
    "objectID": "Python_numpy.html#ejemplo",
    "href": "Python_numpy.html#ejemplo",
    "title": "Errores",
    "section": "Ejemplo",
    "text": "Ejemplo\nSe quiere calcular el área de un rectángulo con base \\(b\\) y altura \\(h\\). Se miden las dimensiones del rectángulo y se obtienen los valores \\(b = 2.5 \\pm 0.1\\) y \\(h = 3.0 \\pm 0.1\\). El área del rectángulo es \\(A = b \\times h\\). ¿Cuál es el valor de \\(A\\) y cuál es su incertidumbre?\nNote que aquí se la incertidumbre seria de 0.01. Ahora si calculamos el perimetro del rectangulo, el cual es \\(P = 2b + 2h\\), la incertidumbre seria de 0.4. Esto se debe a que el error se propaga a traves de la suma.\n** Buscamos crear algoritmos donde el error se propague de manera controlada. **"
  },
  {
    "objectID": "Python_numpy.html#ejemplo-1",
    "href": "Python_numpy.html#ejemplo-1",
    "title": "Errores",
    "section": "Ejemplo 1",
    "text": "Ejemplo 1\nSean las sucesiones \\(\\{a_n\\}\\) y \\(\\{b_n\\}\\) definidas por\n\\[a_n = \\frac{n+1}{n^2} \\quad \\text{y} \\quad b_n = \\frac{n+3}{n^3}\\]\nnote que ambas sucesiones convergen a cero. Sea \\(\\hat{a}_n=\\frac{1}{n}\\) y \\(\\hat{b}_n=\\frac{1}{n^2}\\)\n\\[|a_n-0|=\\frac{n+1}{n^2}\\leq \\frac{n+n}{n^2}=2\\frac{1}{n}=2\\hat{a}_n\\]\ny\n\\[ |b_n-0|=\\frac{n+3}{n^3}\\leq \\frac{n+3n}{n^3}=4\\frac{1}{n^2}=4\\hat{b}_n\\]\nde modo que\n\\[a_n=0+O\\Big(\\frac{1}{n}\\Big) \\quad \\text{y} \\quad b_n=0+O\\Big(\\frac{1}{n^2}\\Big)\\]\nEsto quiere decir que la rápidéz de convergencia de \\(\\{b_n\\}\\) es mayor que la de \\(\\{a_n\\}\\)\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nx=np.linspace(0,1,10)\ny1=1/x\ny2=1/x**2\nplt.plot(x,y1,'r--',x,y2,'b--')\nplt.xlabel('x')\nplt.ylabel('y')\nplt.title('velocidad de comparación')\nplt.legend(['y=1/x','y=1/x^2'])\nplt.show()\n\n/tmp/ipykernel_101551/3491951731.py:4: RuntimeWarning: divide by zero encountered in divide\n  y1=1/x\n/tmp/ipykernel_101551/3491951731.py:5: RuntimeWarning: divide by zero encountered in divide\n  y2=1/x**2\n\n\n\n\n\nSuponga que \\(\\lim_{h\\to 0}G(h)=0\\) y \\(\\lim_{h\\to 0}F(h)=L\\). Si existe una constate positiva \\(K\\) tal que\n\\[|F(h)-L|\\leq K|G(h)|\\]\npara todo \\(h\\) suficientemente pequeño \\(0\\), entonces\n\\(F(h)=L+O\\Big(G(h)\\Big)\\)."
  },
  {
    "objectID": "biseccion.html",
    "href": "biseccion.html",
    "title": "Método de la bisección",
    "section": "",
    "text": "Método de la bisección para encontrar raíces de una ecuación\nSea una función \\(f(x)\\) continua en un intervalo \\([a,b]\\) tal que \\(f(a)\\) y \\(f(b)\\) tienen signos opuestos. Entonces existe al menos un número c en (a,b) tal que \\(f(c)=0\\).\n\n\n\nMétodo\n\n\nEl método de la bisección consiste en dividir el intervalo por la mitad y seleccionar el subintervalo que tiene signos opuestos en los extremos. Este proceso se repite hasta que el intervalo sea lo suficientemente pequeño. Note que este es un algoritmo iterativo, por ende, necesitamos algunos criterios de parada. ¿Cuáles criterios de parada podemos usar?\n\nEjericio:\n\nGrafique la función \\(f(x)=x^3-2x^2+3x-1\\) en el intervalo \\([0,1]\\).\n¿Qué criterios de parada podemos usar para este método?\nNote que esta función tiene una raíz en el intervalo \\([0,1]\\). Intente escribir un algoritmo para implementar el método de la bisección para encontrar la raíz de la función.\nCompare ese algoritmo con el siguiente:\n\n\nEntrada Extremos \\(a,b\\) del intervalo, tolerancia \\(TOL\\), número máximo de iteraciones \\(N_0\\).\nSalida Aproximación \\(p\\) de la raíz de \\(f(x)\\) tal que satisfaga el criterio de parada o un mensaje de error.\nPaso 1. Tome \\(i=1\\); \\[FA=f(a);\\]\nPaso 2. Mientras \\(i\\leq N_0\\) haga paso 3-6\nPaso 3. \\(p=a+(b-a)/2\\); (cálcule \\(p_i\\)) \\[FP=f(p);\\]\nPaso 4. Si \\(f(p)=0\\) o \\((b-a)/2<TOL\\) entonces\nSalida (\\(p\\)); (la salida es \\(p_i\\))\nPaso 5. \\(i=i+1\\);\nPaso 6. Si \\(FA\\cdot FP>0\\) entonces \\[a=p;\\ \\ FA=FP\\] Si no \\[b=p;\\] Paso 7. Salida (Fracaso, el número máximo de iteraciones fue excedido)\n\n\nEjercicio 2:\nImplemente el método de la bisección para encontrar la raíz de la función \\(f(x)=x^3-2x^2+3x-1\\) en el intervalo \\([0,1]\\) y genere una tabla como la siguiente\nIteración | \\(a_n\\) | \\(b_n\\) | \\(p_n\\) | \\(f(p_n)\\) | \\(Error_{absoluto}\\) |\\(Error_{relativo}\\)|\n\n## Método de la bisección\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef f(x):\n    return x**3 + 4*x**2 - 10\n\ndef biseccion(a, b, tol, max_iter):\n    if f(a)*f(b) < 0:\n        i = 0\n        while i < max_iter:\n            c = (a + b)/2\n            if f(c) == 0 or (b - a)/2 < tol:\n                return c\n            i += 1\n            if f(a)*f(c) > 0:\n                a = c\n            else:\n                b = c\n        return c\n    else:\n        print(\"No hay raíz en el intervalo\")\n\n\n\nTeorema\nSuponga que \\(f\\) es continua en \\([a,b]\\) y que \\(f(a)\\) y \\(f(b)\\) tienen signos opuestos. El método de bisección produce una secuencia de intervalos \\(\\{p_n\\}\\) que convergen a un número \\(p\\) tal que \\(f(p)=0\\), tal que \\[|p_n-p|\\leq \\frac{b-a}{2^n}\\]\nEjercicio compruebe esta afirmación numericamente"
  },
  {
    "objectID": "newton.html",
    "href": "newton.html",
    "title": "Newton Rapshon",
    "section": "",
    "text": "Método de Newton Rapshon\n\n\n\nMétodo de Newton\n\n\nForma gráfica\nEl método de Newton-Raphson es un método de segundo orden para encontrar raíces de una función \\(f(x)\\), es decir, encontrar \\(x\\) tal que \\(f(x)=0\\). Para obtener el algoritmo del método vamos a usar el desarrollo de Taylor de \\(f(x)\\) alrededor de \\(x_0\\):\n\\[f(x) = f(x_0) + f'(x_0)(x-x_0) + \\frac{f''(x_0)}{2!}(x-x_0)^2 + \\frac{f'''(x_0)}{3!}(x-x_0)^3 + \\cdots\\] truncando la serie a primer orden y despejando \\(x\\) obtenemos: \\[0=f(x_0) + f'(x_0)(x-x_0)+O(|x-x_0|^2)\\] Note que aquí podemos construir una función \\[g(x) = f(x_0) + f'(x_0)(x-x_0)\\] que pasa por el punto \\((x_0,f(x_0))\\) y tiene pendiente \\(f'(x_0)\\), es decir, es la recta tangente a \\(f(x)\\) en \\(x_0\\), de esta forma podemos definir \\(x_1\\) como la intersección de \\(g(x)\\) con el eje \\(x\\), de donde \\[x_1 = x_0 - \\frac{f(x_0)}{f'(x_0)}\\] de forma iterativa tenemos el método de Newton-Raphson:\n\\[x_{n+1} = x_n - \\frac{f(x_n)}{f'(x_n)}\\]\nNote que el método de Newton-Raphson es un método de segundo orden, es decir, el error en la aproximación \\(x_n\\) es proporcional al cuadrado del error en la aproximación \\(x_{n-1}\\).\nNote que el método de Newton-Raphson requiere el cálculo de la derivada de \\(f(x)\\), en algunos casos esto puede ser complicado, en estos casos se puede usar el método de la secante que es una aproximación numérica de la derivada.\nNote que el método de Newton-Raphson puede no converger, en estos casos se puede usar el método de la bisección.\nNote que el algoritmo necesita un punto inicial \\(x_0\\) cercano a la raíz que se quiere encontrar.\nEjercicio Escriba cuales son las ventajas y desventajas del método de Newton Raphson sobre el método de la bisección.\n\n## newton rapson method\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport math\ndef f(x):\n    return x**3-2*x-5\ndef df(x):\n    return 3*x**2-2\ndef newton(x0,eps):\n    x1=x0-f(x0)/df(x0)\n    while abs(x1-x0)>eps:\n        x0=x1\n        x1=x0-f(x0)/df(x0)\n    return x1\n\nEjercicio Note que el algoritmo anterior tiene un problema. ¿Cuál es? ¿Cómo lo solucionaría?\nReescriba el algoritmo anterior para que no tenga el problema que identificó.\nNote que en este método tenemos que calcular la derivada, lo podemos hacer de dos formas:\n\nEscribir deiractamente la derivada de la función.\nUtilizar la función Derivative de SymPy y luego evaluarla en el punto.\n\nEn el siguiente código usted vera como se puede usar la función Derivative de SymPy para calcular la derivada de una función y luego evaluarla en un punto.\n\nimport sympy as sp\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Definir la variable simbólica\nx = sp.symbols('x')\n\n# Definir la función simbólica\nfuncion_simbolica = x**2 + 3*x + 2\n# Función numpy\nfuncion_numpy = sp.lambdify(x, funcion_simbolica, 'numpy')\n\n# Calcular la derivada\nderivada_simbolica = sp.diff(funcion_simbolica, x)\n\n# Convertir la derivada en una función de NumPy\nderivada_numpy = sp.lambdify(x, derivada_simbolica, 'numpy')\n\n# Crear un rango de valores para x\nx_vals = np.linspace(-10, 10, 400)\n\n# Calcular los valores correspondientes para la función y su derivada\nfuncion_vals = funcion_numpy(x_vals)\nderivada_vals = derivada_numpy(x_vals)\n\n\n\n# Crear una figura y ejes\nplt.figure(figsize=(10, 6))\nplt.title('Función y su Derivada')\nplt.xlabel('x')\nplt.ylabel('y')\n\n# Graficar la función original\nplt.plot(x_vals, funcion_vals, label='Función Original')\n\n# Graficar la derivada\nplt.plot(x_vals, derivada_vals, label='Derivada')\n\n# Mostrar leyenda\nplt.legend()\n\n# Mostrar el gráfico\nplt.grid()\nplt.show()\n\n\n\n\nEjercicio Use el anterior código para reformar el método de Newton-Raphson para que solo se necesite la función \\(f\\) y el internamente se calcule la derivada simbólica.\n\n\nlibrerías externas\nExisten diferentes librerías para calcular encontrar la raíz de una función, en este caso se usará la librería de scipy, la cual contiene una función llamada newton que permite encontrar la raíz de una función, para esto se debe ingresar la función, la derivada de la función y el valor inicial de la raíz. en el siguiente enlace encontraras las funciones que contiene la librería de scipy.\nEjercicio + Lea atentamente la documentación y haga un resumen de lo encontrado. + Encuentre la raíz de la función \\(f(x)=x^3-2x^2-5\\), usando los métodos de bisección y newton (su implementación, y el de la librería scipy ), compare los resultados obtenidos, aproximación, tiempo de computo, número de iteraciones, etc.\nPara elvaluar el tiempo de computo usted puede usar el siguiente código:\n```python\nimport time\n# Registro del tiempo de inicio\nstart_time = time.time()\n\n# Código de tu algoritmo\n# ...\n\n# Registro del tiempo de finalización\nend_time = time.time()\n\n# Cálculo del tiempo de ejecución\nexecution_time = end_time - start_time\n\nprint(\"Tiempo de ejecución:\", execution_time, \"segundos\")\n```"
  },
  {
    "objectID": "puntofixo.html",
    "href": "puntofixo.html",
    "title": "Cálculo numérico",
    "section": "",
    "text": "Un función que tiene punto fijo es una función que cumple que existe un punto \\(x\\) tal que \\(f(x) = x\\).\nPor ejemplo la función \\(f(x) = x^2\\) tiene un punto fijo en \\(x=1\\) ya que \\(f(1) = 1\\).\n\nimport sympy     as sp\n\nx, y = sp.symbols('x y')\n\n# Definir las funciones\nfunc1 = x**2\nfunc2 = x\n\n# Graficar las funciones usando sp.plot\np1 = sp.plot(func1, (x, -1, 5), line_color='blue', show=False, label='x^2')\np2 = sp.plot(func2, (x, -1,5), line_color='red', show=False, label='x')\n\n# Personalizar el gráfico\np1.extend(p2)\np1.xlabel = 'x'\np1.ylabel = 'y'\np1.title = 'Note que la figura tiene un punto fijo'\np1.legend = True\np1.ylim = (-1.5, 1.5)\np1.show_grid = True \n\n\n# Mostrar el gráfico\np1.show()\n\n\n\n\nAhora queremos queremos encontrar un algoritmo iterativo que no ayude a encontrar el punto fijo, veamos la siguiente animación\n\n\n\nPunto fijo\n\n\n\n¿Que condiciones debe tener una función para tener un punto fijo?\nVamos a explorar el concepto de la función contractiva, definir el concepto de función contractiva. :::{admonition}\nUna función \\(f(x)\\) es contractiva en un intervalo \\([a,b]\\) si existe una constante \\(k\\) tal que \\(0<k<1\\) y para todo \\(x\\) y \\(y\\) en \\([a,b]\\) se cumple que \\[|f(x)-f(y)|\\leq k|x-y|\\] :::"
  },
  {
    "objectID": "taller_resumen_1.html",
    "href": "taller_resumen_1.html",
    "title": "Taller Resumen",
    "section": "",
    "text": "Ejercicio de Métodos numéricos para ingenieros-Chapra, 7ed La función \\(\\sin x\\), puede evaluarse mediante la serie infinita \\[\\sin x=x-\\frac{x^3}{3!}+\\frac{x^5}{5!}-\\frac{x^7}{7!}\\]\n\nescriba un algoritmo para implementar esta formula de modo que calcule e imprima los valores de \\(\\sin x\\) con forme se agregue cada termino de la serie. En otras palabras, calcule e imprima la secuencia de valores para \\[\\sin x=x\\] \\[\\sin x=x-\\frac{x^3}{3!}\\] \\[\\sin x=x-\\frac{x^3}{3!}+\\frac{x^5}{5!}\\] hasta el término de orden \\(n\\) que usted elija. Para cada uno de los valores anteriores, calcule y haga que se muestre el error porcentual relativo:\n\\[\\% error=\\frac{v_v-a_s}{v_v}\\times100\\%\\]\nEscriba el algoritmo para\n\ndiagrama de flujo estructurado,\npseudocódigo.\n\n\nDefina que es error relativo, error absoluto, error de truncamiento, error de redondeo.\nElabore un pseudocódigo usando el método de la bisección usando los criterios siguientes criterios de parada\n\n\nError absoluto, \\(|x_{n-1}-x_n|\\).\nError relativo, \\(\\frac{|x_{n-1}-x_n|}{|x_n|}\\), si \\(x_n\\neq0\\)\n“criterio de función” \\(|f(x_{n-1})-f({x_n})|\\)\n\n\n¿Qué mide el criterio de función?\nPrograme el pseudocódigo anterior en Python y aplique el método de la bisección para encontrar la raíz de la función \\(f(x)=x^3-2x^2+4x-8\\) en el intervalo \\([1,3]\\) con una tolerancia de \\(10^{-4}\\), calculando el error absoluto, relativo y el criterio de función.\nEl siguiente código está programado en python y usa el método de newton\n\ndef newton(f,df,x0,tol=1e-5,maxiter=15):\n    x = x0\n    for i in range(maxiter):\n        dx = -f(x)/df(x)\n        x = x + dx\n        if abs(dx/x) < tol: return x,i\n    print('Son demasiadas iteraciones\\n')\n\nEste algoritmo usa adecuadamente todos los criterios para programar el método de newton\nSi es necesario modifique el algoritmo para que el programa genera una buena aproximación del método de newton\n\n\nHaga un comparación del método de Newton, método de la bisección y el método del punto fijo.\nUse los métodos anteriores para encontrar la raíz de la función \\(f(x)=x^3-2x^2+4x-8\\) en el intervalo \\([1,3]\\) con una tolerancia de \\(10^{-4}\\), calculando el error absoluto, relativo y imprimiendo el numero de iteraciones.\nSe quiere resolver el siguiente problema\n\nUn filtro de paso de banda paso señales con una frecuencia que son dentro de cierto rango. En este filtro el radio de la magnitud del voltaje es dado por \\[\nRV=\\left|\\frac{V_0}{V_i}\\right|=\\frac{\\omega RC}{\\sqrt{(1-\\omega^ 2LC)^ 2+(\\omega RC)^ 2}},\n\\] donde \\(\\omega\\) es la frecuencia de la señal de entrada. Dado \\(R=1000 \\Omega\\) \\(L=11mH\\) y \\(C=8\\mu F\\) se requiere determinar el rango de frecuencia que corresponde para \\(RV\\geq 0.87\\)\n\nEscriba un pseudocódigo para resolver el problema anterior\nSi es necesario usar un método para encontrar las raíces de la función \\(RV\\). ¿Qué método usaría? ¿Por qué? ¿Qué criterio de parada usaría? ¿Por qué? ¡Justifique su respuesta!\n\n\nTome \\(f(x)=x^2-6\\) y \\(p_0=1\\). Use el método de Newton para encontrar \\(p_3\\) (tres iteraciones del método)\nTome \\(f(x)=-x^3-cos(x)\\) y \\(p_0=1\\). Use el método de Newton para encontrar \\(p_3\\). Puede \\(p_0=0\\) ser usado?\nEl polinomio de grado 4 \\(f(x)=230x^4+18x^3+9x^2-221x-9\\) tiene 2 raíces reales en los intervalos \\([-1,0]\\) y \\([0,1]\\). Intente aproximar esos ceros con una precisión de \\(10^{-6}\\) usando:\n\n\nmétodo de Newton,\nMétodo de la bisección\nPunto fijo\n¿Qué método escogería para resolver este problema? ¿Por qué?\n¿Qué criterio de parada usaría? ¿Por qué?\n\n\nEn la ingeniería ambiental, la ecuación siguiente se emplea para calcular el nivel de oxígeno \\(c\\) (mg/L) en un río aguas abajo de la descarga de un drenaje: \\[c=10-20(e^{-0.15x}-e^-0.5x)\\] donde \\(x\\) es la distancia aguas abajo en km.\n\n\nEscriba un pseudocódigo para resolver el problema anterior\nDetermine la distancia aguas abajo de la corriente, a la cual el nivel de oxigeno cae hasta una lectura de 5mg/L. Encuentre la respuesta con una presión de \\(10^{-3}\\).\nCalcule la distancia aguas abajo a la cual el oxígeno se encuentra al mínimo.\n\n\nEl desplazamiento de una estructura esta definido por la siguiente ecuación para una oscilación amortiguada: \\[y=9e^{-kt}cos (\\omega t)\\]\n\nDonde \\(k=0.695\\) y \\(\\omega =3.92\\) +\nUtilice el método gráfico para realizar una estimación inicial del tiempo que se requiere para que el desplazamiento disminuya a 3.5\n\nEmplee el método de Newton para determinar la raíz con una exactitud de \\(10^{-5}\\)\n\n\nRealice la gráfica de un ejemplo de una función que tenga raíz en un intervalo cerrado y donde no se pude usar el método de Newton.\nRealice la gráfica de un ejemplo de una función que tenga raíz en un intervalo cerrado y en donde no se pude usar el método de Bisección.\n¿Qué consideraciones debo tener para usar el método de Newton? Explique y de ejemplos\n¿Qué consideraciones debo tener para usar el método de Bisección? Explique y de ejemplos\nDeduzca el algoritmo de Newton para encontrar la raíz de una función \\(f(x)\\)\nDeduzca el algoritmo de Bisección para encontrar la raíz de una función \\(f(x)\\)\n¿Qué consideraciones debo tener para usar el método de Punto fijo? Explique y de ejemplos\nCuales son las propiedades de las normas de vectores y de matrices\nPara que puedo usar las normas de vectores y de matrices\nLe realice la siguiente pregunta a Chatgpt ¿Qué es mejor en problemas de análisis numérico trabajar con números grandes que con números pequeños?\n\n```En problemas de análisis numérico, la elección entre trabajar con números grandes o pequeños depende de la naturaleza específica del problema y de las limitaciones numéricas de los algoritmos involucrados. En algunos casos, puede ser necesario trabajar con números grandes, mientras que en otros, números pequeños son más apropiados. Aquí hay algunas consideraciones:\nTrabajar con números grandes puede ser mejor cuando:\n\nPrecisión requerida: Si el problema requiere una alta precisión en los resultados y los números involucrados son naturalmente grandes, como en cálculos astronómicos o financieros a gran escala, es necesario trabajar con números grandes para evitar pérdidas significativas de precisión.\nReducción de errores de redondeo: En algunos algoritmos numéricos, especialmente aquellos que involucran sumas o productos acumulativos, trabajar con números grandes puede ayudar a reducir los errores de redondeo acumulativos que pueden afectar la precisión de los resultados.\nMantener magnitudes significativas: En problemas donde las magnitudes de los números son esenciales para el análisis, trabajar con números grandes puede ser necesario para representar adecuadamente la información del problema.\n\nTrabajar con números pequeños puede ser mejor cuando:\n\nEficiencia computacional: En ciertas situaciones, como simulaciones numéricas de alto rendimiento, trabajar con números pequeños puede ser más eficiente en términos de velocidad de cálculo y uso de memoria.\nEvitar desbordamientos y errores: En algoritmos donde los números crecen exponencialmente o tienen potencial para desbordarse, trabajar con números pequeños puede ser una estrategia para evitar problemas numéricos.\nEstabilidad numérica: Algunos algoritmos numéricos son más estables cuando se utilizan números pequeños, ya que los errores de redondeo tienden a ser menos problemáticos.\nOptimización de recursos: En entornos computacionales con recursos limitados, como sistemas embebidos o dispositivos móviles, trabajar con números pequeños puede ser necesario debido a restricciones de memoria y potencia de cálculo.\n\nEn última instancia, la elección entre números grandes y pequeños en problemas de análisis numérico debe basarse en un análisis detallado de las características del problema y las limitaciones de los algoritmos disponibles. A menudo, es útil realizar pruebas y experimentos para determinar cuál enfoque es más adecuado para un problema en particular, equilibrando la precisión, la eficiencia y la estabilidad numérica.\n+ ¿Qué puedo decir de la respuesta anterior?\n+ ¿Todas las afirmaciones son correctas? \n\n26. Le realice la siguiente pregunta a Chatgpt\n**quiero que código en python  para graficar una circunferencia usando norma lp**\n\nPara graficar una circunferencia en Python utilizando la norma \\(L_p\\), puedes utilizar la biblioteca `matplotlib` para trazar la gráfica y la biblioteca `numpy` para realizar cálculos. La norma \\(L_p\\) se utiliza para definir una circunferencia en función de una distancia dada. Aquí tienes un ejemplo de código que grafica una circunferencia usando la norma \\(L_p\\):\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Definir el radio de la circunferencia y el valor de p\nradio = 1.0  # Puedes ajustar el radio según tus necesidades\np = 2        # Puedes ajustar el valor de p (2 para la norma L2, 1 para la norma L1, etc.)\n\n# Generar puntos en la circunferencia\ntheta = np.linspace(0, 2 * np.pi, 1000)  # Ángulos desde 0 hasta 2*pi\nx = radio * np.cos(theta)\ny = radio * np.sin(theta)\n\n# Elevar las coordenadas a la potencia p\nx_p = np.power(np.abs(x), p) * np.sign(x)\ny_p = np.power(np.abs(y), p) * np.sign(y)\n\n# Crear la figura y el gráfico\nplt.figure(figsize=(6, 6))\nplt.plot(x_p, y_p, label=f'Norma L{p}')\nplt.xlabel('X')\nplt.ylabel('Y')\nplt.title(f'Circunferencia con Norma L{p}')\nplt.grid(True)\nplt.axis('equal')  # Para asegurar que la escala en X e Y sea igual\nplt.legend()\nplt.show()\nEste código generará una gráfica de una circunferencia utilizando la norma (L_p) con el radio especificado y el valor de (p) dado. Puedes ajustar radio y p según tus necesidades. La función np.power se utiliza para elevar las coordenadas a la potencia (p) según la norma (L_p). El resultado es una circunferencia con la norma (L_p) especificada.\n\n¿El código anterior es correcto?\n¿Es posible modificar el código anterior para graficar una circunferencia usando la norma \\(L_p\\)? ¿Cómo? ¡Justifique su respuesta!\nEscriba un código en python para graficar una circunferencia usando la norma \\(L_p\\)\n\n\nDefina el numero de condición de una matriz y para que sirve. ¿Qué es una matriz mal condicionada? ¿Que relación tiene el numero de condición con el error de redondeo?\nImplemente este código en python\n\neps = 1.0\nwhile 1.0 + eps != 1.0:\n    eps /= 2.0\nprint(eps)\n¿Que arroja el código anterior? ¿Qué significa?\n\nImplemente este código en python\n\n\ndef puntofijo(g, x0, tol, n):\n    for k in range(n):\n        x1 = g(x0)\n        if abs(x1 - x0) < tol:\n            return x1, k\n        x0 = x1\n    print('Son demasiadas iteraciones\\n')\ng = lambda x: 1 + 1/x\nx0 = 1\ntol = 1e-5\nn = 100\n¿Qué debería hacer este código?¿Este código es correcto? ¿Por qué? ¿Qué se puede hacer para mejorarlo?\n\nImplemente este código en python\n\n\ndef biseccion(f, a, b, tol, n):\n    for k in range(n):\n        p = a + (b - a)/2\n        if abs(f(p)) < tol:\n            return p, k\n        elif f(a)*f(p) < 0:\n            b = p\n        else:\n            a = p\n    print('Son demasiadas iteraciones\\n')\nf = lambda x: x**2 - 2\na = 0\nb = 1\ntol = 1e-5\nn = 100\n¿Qué debería hacer este código? ¿Este código es correcto? ¿Por qué? ¿Qué se puede hacer para mejorarlo?"
  },
  {
    "objectID": "taller.html",
    "href": "taller.html",
    "title": "Método de la bisección",
    "section": "",
    "text": "Taller 1 de calculo numérico\nDebe hacer los primeros ejercicios de la guía de calculo numérico para entregar a las 1:00 pm del 15 de agosto de 2020. El taller debe ser entregado en un archivo .ipynb. El taller debe ser realizado en grupos de máximo 3 personas. En el archivo .ipynb debe estar el nombre de los integrantes del grupo.\nUna simplificación del modelo de suspensión de un automóvil consiste en una masa, un resorte con rigidez \\(k\\) y con coeficiente de amortiguamiento \\(c\\), como se muestra en la figura. Un carretera llena de huecos se puede modelar mediante un movimiento sinusoidal hacia arriba y hacia abajo de la rueda. \\(y=Y\\sin(\\omega t)\\). A partir de la solución de la ecuación de movimiento para este modelo, el movimiento de arriba y abajo del automóvil (masa) está dado por \\(x=X\\sin(\\omega t - \\phi)\\). La relación entre la amplitud \\(X\\) y la amplitud \\(Y\\) está dada por: \n\\[\\frac{X}{Y}=\\sqrt{\\frac{\\omega^2c+k}{(k-m\\omega^2)+(c\\omega)^2}}\\]\nAsumiendo que \\(m=2500 kg\\), \\(k=300kH/m\\) y \\(c=36\\times 10^3 Ns/m\\), determine la frecuencia \\(\\omega\\) para la cual la relación \\(X/Y=0.4\\).\n\nsolucione la ecuaicón anterior para \\(\\omega\\), usando el método de Newton-Raphson, con una tolerancia de \\(10^{-6}\\). Encuente una condición inicial adecuada.\nSe puede resolver usando el método de la bisección?\nReescriba la ecuación como un polinomio en términos de \\(\\omega\\)\n\nSuponga el lector que está diseñando un tanque esférico de almacenamiento de agua para un poblado pequeño de un país en desarrollo. El volumen del líquido que puede contener se calcula con \\[V=\\pi h^2\\frac{3R-h}{3}\\] donde \\(V =\\) volumen \\([pie^3]\\), \\(h =\\) profundidad del agua en el tanque \\([pies]\\), y \\(R =\\) radio del tanque \\([pies]\\). Si \\(R = 3 m\\), ¿a qué profundidad debe llenarse el tanque de modo que contenga \\(30 m^3\\)? Haga tres iteraciones del método de Newton- Raphson para determinar la respuesta. Encuentre el error relativo aproximado después de cada iteración. Observe que el valor inicial de R convergerá siempre. ¿Se puede usar el método de bisección?\n\n\n\nfigura\n\n\n\nimport numpy as np\n\ndef LU(A):\n    n = A.shape[0]\n    L = np.eye(n)\n    U = A.copy()\n    \n    for i in range(n - 1):\n        L[i+1:, i] = U[i+1:, i] / U[i, i]\n        U[i+1:, i:] -= np.outer(L[i+1:, i], U[i, i:])\n    \n    return L, U\n\n# Ejemplo de uso\nA = np.array([[2, 3, 1],\n              [4, 7, 7],\n              [4, 8, 9]], dtype=float)\n\nL, U = LU(A)\n\nprint(\"Matriz A:\")\nprint(A)\nprint(\"\\nMatriz L:\")\nprint(L)\nprint(\"\\nMatriz U:\")\nprint(U)\n\n# Verificamos que la descomposición LU sea correcta\nreconstruida = np.dot(L, U)\nprint(\"\\nMatriz L * Matriz U (Reconstruida):\")\nprint(reconstruida)\n\nMatriz A:\n[[2. 3. 1.]\n [4. 7. 7.]\n [4. 8. 9.]]\n\nMatriz L:\n[[1. 0. 0.]\n [2. 1. 0.]\n [2. 2. 1.]]\n\nMatriz U:\n[[ 2.  3.  1.]\n [ 0.  1.  5.]\n [ 0.  0. -3.]]\n\nMatriz L * Matriz U (Reconstruida):\n[[2. 3. 1.]\n [4. 7. 7.]\n [4. 8. 9.]]"
  },
  {
    "objectID": "punto_fijo.html",
    "href": "punto_fijo.html",
    "title": "Método del punto fijo",
    "section": "",
    "text": "Decimos que una función tiene un punto fijo si existe un valor \\(x^*\\) tal que \\(f(x^*) = x^*\\).\nPor ejemplo, la función \\(f(x) = x^2\\) tiene un punto fijo en \\(x^* = 0\\) y \\(x^*=1\\).\nEsta definición la podemos usar para encontrar la raíz de una ecuación \\(f(x) = 0\\).\n\n\n\\[f(x)=x^3+x-1\\] aquí podremos encontrar una raíz de la ecuación \\(f(x)=0\\) si encontramos un punto fijo en la función \\(g(x)=x-f(x)\\). De esta forma \\[g(x)=x-f(x)=x-x^3-x+1=x^3-1\\]\n\n\n\nDado \\(x_0\\) x inicial queremos encontrar \\[x_{i+1}=g(x_i)\\] tal que \\(x_{i+1}\\) converja a \\(x^*\\).\nSi una iteración del punto fijo converge a \\(x^*\\), entonces \\(x^*\\) es un punto fijo de \\(g(x)\\)\n\n\n\nUna función \\(g(x)\\), diferenciable en \\((a,b)\\) y continua en \\([a,b]\\), esta tiene un punto fijo en \\(x^*\\) en \\([a,b]\\) si existe un \\(k\\) tal que \\[|g'(x)|<k\\leq 1\\]\n\n\n\nQueremos encontrar la raíz de la ecuación \\(f(x)=x^3+x-1\\) usando el método del punto fijo. Para esto lo primero que deberíamos hacer es verificar que la función \\(f(x)\\) tengo una raíz. Para esto graficamos la función \\(f(x)\\)\n\nimport sympy as sp\nx=sp.Symbol('x')\nf=x**3+x-1\n\nsp.plot(f, (x, -1, 1), ylim=(-1, 1), ylabel='g(x)', xlabel='x')\n\n\n\n\n<sympy.plotting.plot.Plot at 0x7fb520c77a90>\n\n\nTenemos varias candidatas para la función \\(g\\), vamos a explorar algunas de ellas. 1. Note que si \\[f(x)=x^3+x-1\\] podemos reescribir la ecuación como \\[x^3+x-1=0\\] \\[x=1-x^3\\] así obtenemos \\(g_1\\) \\[g_1(x)=1-x^3\\] 2. Note que si \\[x^3+x-1=0\\] \\[x^3=1-x\\] \\[x=\\sqrt[3]{1-x}\\] así obtenemos \\(g_2\\) \\[g_2(x)=\\sqrt[3]{1-x}\\] 3. Note que si \\[x^3+x-1=0\\] \\[x^3+x=1\\] \\[x(x^2+1)=1\\] así obtenemos \\(g_3\\) \\[g_3(x)=\\frac{1}{1+x^2}\\]\n\nNote que si \\[x^3+x-1=0\\] \\[3x^3+x=1+2x^3\\] \\[x(3x^2+1)=1+2x^3\\]\n\n\\[x=\\frac{1+2x^3}{3x^2+1}.\\] así obtenemos \\(g_3\\) \\[g_4(x)=\\frac{1+2x^3}{3x^2+1}\\]\nAhora vamos a probar si las funciones \\(g_i\\) tienen un punto fijo. Para esto vamos a ver si la iteración del punto fijo converge a un punto fijo de \\(g_i\\).\n\n\n\n\nimport pandas as pd\n## iteración del punto fijo\ndef punto_fijo(f, x0, tol, maxiter):\n    df=[]\n    x = x0\n    for i in range(maxiter):\n        x_new = f(x)\n        error = abs(x_new - x)\n        df.append([i, x_new, error])\n        if error < tol:\n            print(\"El método converge en la iteración:\", i)\n            return x_new, i, df,True\n        x = x_new\n        \n    print(\"El método no converge después de\", maxiter, \"iteraciones\")\n    \n    return x, maxiter, df, False\n\ng= lambda x: 1-x**3\nx0=0.5\ntol=1e-5\nmaxiter=15\npunto_fijo(g, x0, tol, maxiter)\n\nEl método no converge después de 15 iteraciones\n\n\n(1.0,\n 15,\n [[0, 0.875, 0.375],\n  [1, 0.330078125, 0.544921875],\n  [2, 0.9640374705195427, 0.6339593455195427],\n  [3, 0.10405418832767732, 0.8599832821918654],\n  [4, 0.9988733767808354, 0.8948191884531581],\n  [5, 0.003376063247859995, 0.9954973135329754],\n  [6, 0.999999961520296, 0.996623898272436],\n  [7, 1.1543910749534092e-07, 0.9999998460811885],\n  [8, 1.0, 0.9999998845608925],\n  [9, 0.0, 1.0],\n  [10, 1.0, 1.0],\n  [11, 0.0, 1.0],\n  [12, 1.0, 1.0],\n  [13, 0.0, 1.0],\n  [14, 1.0, 1.0]],\n False)\n\n\nComo vimos anteriormente la iteración no converge. Verifiquemos si la función \\(g_1\\) cumple con el teorema del punto fijo. Para esto calculemos la derivada de \\(g_1\\) y la graficaremos en el intervalo \\([0.5,0.75]\\). Para ello vamos a calcular la derivada de \\(g_1\\) usando la libreria sympy\n\nimport sympy as sp\nx=sp.Symbol('x')\ng=1-x**3\ndg=sp.diff(g, x)\nsp.plot(dg, (x, 0.5, 0.75),  ylabel='g(x)', xlabel='x',title='Derivada de  $g_1(x)$')\n\n\n\n\n<sympy.plotting.plot.Plot at 0x7fb52077d990>\n\n\nComo vemos en ese intervalo tenemos que la función no cumple con el teorema del punto fijo, puesto que en algunos puntos la derivada es mayor que 1.\n\n\n\nVamos primero a verificar si cumple el teorema del punto fijo. Para esto calculemos la derivada de \\(g_2\\) y la graficaremos en el intervalo \\([0.5,0.75]\\). Para ello vamos a calcular la derivada de \\(g_2\\) usando la libreria sympy\n\nimport sympy as sp\nx=sp.Symbol('x')\ng=sp.cbrt(1-x)\ndg=sp.diff(g, x)\nsp.plot(dg, (x, 0.5, 0.75),  ylabel='g(x)', xlabel='x',title='Derivada de  $g_2(x)$')\n\n\n\n\n<sympy.plotting.plot.Plot at 0x7fb52048a050>\n\n\nComo observamos en la gráfica la función cumple con el teorema del punto fijo. Ahora vamos a ver si la iteración converge a un punto fijo de \\(g_2\\).\n\ng= lambda x: pow(1-x,1/3)\nx0=0.5\ntol=1e-2\nmaxiter=12\nx,iter_al,df,estado=punto_fijo(g, x0, tol, maxiter)\n\nEl método converge en la iteración: 11\n\n\n\nimport matplotlib.pyplot as plt\nimport pandas as pd\ndf=pd.DataFrame(df, columns=[\"Iteracion\", \"Aproximacion\", \"Error\"])\ncolumna_a_graficar = df[\"Aproximacion\"]\n\n# Ahora, puedes crear el gráfico\nplt.figure(figsize=(10, 6))  # Opcional: ajusta el tamaño del gráfico\nplt.plot(columna_a_graficar)\nplt.title(\"Convergencia\")\nplt.xlabel(\"Iteración\")\nplt.ylabel(\"Aproximación\")\n\n# Muestra el gráfico\nplt.show()\n\n\n\n\nDe forma similar podemos verificar para \\(g_3\\), ahora en el caso de \\(g_4\\) podemos observar que la función converge en menos iteraciones. Esto es debido a la forma de la función \\(g_4\\), ya que esta después de la primera iteración se acerca más rápido al punto fijo y converge al cabo de 2 iteraciones para la tolerancia de \\(10^{-2}\\)\n\nimport sympy as sp\nx=sp.Symbol('x')\ng=(1+2*x**3)/(1+3*x**2)\n\nsp.plot(g, (x, 0.5, 0.75),  ylabel='g(x)', xlabel='x',title='Función $g_4(x)$')\n\n\n\n\n<sympy.plotting.plot.Plot at 0x7fb52061e510>\n\n\n\ng= lambda x: (1+2*x**3)/(1+3*x**2)\nx0=0.5\ntol=1e-2\nmaxiter=12\nx,iter_al,df,estado=punto_fijo(g, x0, tol, maxiter)\nimport matplotlib.pyplot as plt\nimport pandas as pd\ndf=pd.DataFrame(df, columns=[\"Iteracion\", \"Aproximacion\", \"Error\"])\ncolumna_a_graficar = df[\"Aproximacion\"]\n\n# Ahora, puedes crear el gráfico\nplt.figure(figsize=(10, 6))  # Opcional: ajusta el tamaño del gráfico\nplt.plot(columna_a_graficar)\nplt.title(\"Convergencia\")\nplt.xlabel(\"Iteración\")\nplt.ylabel(\"Aproximación\")\n\n# Muestra el gráfico\nplt.show()\n\nEl método converge en la iteración: 2"
  },
  {
    "objectID": "normas.html",
    "href": "normas.html",
    "title": "Normas",
    "section": "",
    "text": "Norma de un vector \\(l_p\\) Sea \\(x=[x_1,x_2,\\dots,x_n]^T\\) un vector en \\(\\mathbb{R}^n\\), la norma \\(l_p\\) de \\(x\\) se define como: \\[\\|x\\|_p=\\left(\\sum_{i=1}^n|x_i|^p\\right)^{1/p}\\] para \\(1\\leq p<\\infty\\) y \\[\\|x\\|_\\infty=\\max_{1\\leq i\\leq n}|x_i|\\]"
  },
  {
    "objectID": "normas.html#normas-matriciales",
    "href": "normas.html#normas-matriciales",
    "title": "Normas",
    "section": "Normas matriciales",
    "text": "Normas matriciales\nLas normas matriciales inducidas son una forma de medir la magnitud de una matriz en relación con un espacio vectorial. Son útiles en diversas áreas de las matemáticas y la ciencia, incluyendo el álgebra lineal y la teoría de matrices. En este documento, exploraremos las normas matriciales inducidas y cómo se calculan.\nNorma Matricial Inducida por un Vector ** Propiedades\n\nSi \\(A\\) y \\(B\\) son matrices\n\n\\[|\\|AB\\||_p\\leq|\\|A|\\|_p\\||B\\||_p\\]\nLa norma matricial inducida por una norma vectorial se define como: \\[|\\|A\\||_{p} = \\max_{x \\neq 0} \\frac{\\|Ax\\|_{p}}{\\|x\\|_{q}}\\] donde \\(\\|\\cdot\\|_{p}\\) y \\(\\|\\cdot\\|_{q}\\) son normas vectoriales en \\(\\mathbb{R}^{n}\\) y \\(\\mathbb{R}^{m}\\), respectivamente. Esta definiciión se puede reescribir como:\n\\[|\\|A\\||_{p} = \\max_{\\|x\\|_{q} = 1} \\|Ax\\|_{p}\\]\nSi \\(A\\) es una matriz cuadrada, entonces la norma matricial de la norma \\(1\\) se puede escribir como: \\[|\\|A\\||_{1}=max_{1\\leq k\\leq n}\\sum_{j=1}^{n}|A_{j,k}|\\]\n\\[|\\|A\\||_{\\infty}=max_{1\\leq j\\leq n}\\sum_{k=1}^{n}|A_{j,k}|\\]"
  },
  {
    "objectID": "normas.html#ejemplos",
    "href": "normas.html#ejemplos",
    "title": "Normas",
    "section": "Ejemplos",
    "text": "Ejemplos\nVeamos algunos ejemplos de cálculo de normas matriciales inducidas en matrices y vectores específicos.\nEjemplo 1 Dada la matriz \\[A = \\begin{bmatrix} 2 & -1 \\\\ -5 & 4 \\end{bmatrix}\\] y la norma vectorial \\(L_{1}\\), calculemos la norma matricial inducida por \\(L_{1}\\).\n\\[|\\|A\\||_{1} = \\max\\{7,5\\}=7\\]\nNorma infinito\n\\[|\\|A\\||_{\\infty} = \\max\\{3,9\\}=9\\]"
  },
  {
    "objectID": "normas.html#normas-de-frobenius",
    "href": "normas.html#normas-de-frobenius",
    "title": "Normas",
    "section": "Normas de Frobenius",
    "text": "Normas de Frobenius\nLa norma de Frobenius es una norma matricial no inducida. La norma de Frobenius de una matriz \\(A\\) se define como:\n\\[|\\|A\\||_{F} = \\sqrt{\\sum_{i=1}^{m} \\sum_{j=1}^{n} |a_{ij}|^{2}}\\]\n\nimport numpy as np\n\n# Crear una matriz de ejemplo\nA = np.array([[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]])\n\n# Calcular la norma de Frobenius (norma F)\nnorm_frobenius = np.linalg.norm(A, ord='fro')\nprint(\"Norma de Frobenius de A:\", norm_frobenius)\n\n# Calcular la norma infinito (norma ∞)\nnorm_inf = np.linalg.norm(A, ord=np.inf)\nprint(\"Norma infinito de A:\", norm_inf)\n\n# Calcular la norma 1 (norma 1)\nnorm_1 = np.linalg.norm(A, ord=1)\nprint(\"Norma 1 de A:\", norm_1)\n\nNorma de Frobenius de A: 16.881943016134134\nNorma infinito de A: 24.0\nNorma 1 de A: 18.0"
  },
  {
    "objectID": "sol_taller.html",
    "href": "sol_taller.html",
    "title": "Untitled",
    "section": "",
    "text": "import sympy as sp\n#import sympy_plot_backends as spb\nx=sp.Symbol('x',real=True)\nmu=sp.Piecewise((0.05,x<=30),(0.02,x>30))\nbeta=sp.Piecewise((0,x<=15),(0.04,x<=60),(0.02,x>60))\nalpha = 0.01\nF=mu*sp.exp(-alpha*x)-beta\n# Graficar la función\nsp.plot(F,(x,0,200))\n\n# solucion de un edo\ny = sp.Function('y')\nresult = sp.dsolve(sp.Derivative(y(x), x) -F)\nAnalytical solution:\nLet the differential equation:\n\\[\\frac{dV}{dt} = F(t,V)\\] where \\[F(t,V)=\\big(\\mu(v) e^{-\\alpha t}-\\beta(t)\\big)V\\] and \\[\\mu(t) =\n\\begin{cases}\n0.05, & \\text{si } t < 30 \\text{ días} \\\\\n0.02, & \\text{si } t \\geq 30 \\text{ días}\n\\end{cases}\\]\n\\[\\beta(t) =\n\\begin{cases}\n0, & \\text{si } t < 15 \\text{ días} \\\\\n0.04, & \\text{si } 15 \\text{ días} \\leq t < 60 \\text{ días} \\\\\n0.02, & \\text{si } t \\geq 60 \\text{ días}\n\\end{cases}\\]\n\\[\\mu(t) =\n\\begin{cases}\n0.05, & \\text{si } t < 30 \\text{ días} \\\\\n0.02, & \\text{si } t \\geq 30 \\text{ días}\n\\end{cases}\\]\n\\[\\beta(t) =\n\\begin{cases}\n0, & \\text{si } t < 15 \\text{ días} \\\\\n0.04, & \\text{si } 15 \\text{ días} \\leq t < 60 \\text{ días} \\\\\n0.02, & \\text{si } t \\geq 60 \\text{ días}\n\\end{cases}\\]\nwith the initial condition \\(V(0)=2\\). We can solve this equation by separation of variables, and we need to calculate the solution for intervals \\(([0,15],[15,30],[30,60],[60,\\infty])\\).\nFirst, we solve the equation for the interval \\([0,15]\\). We have:\n\\[\\frac{dV}{dt} = \\Big(\\mu(t)  \\exp(-\\alpha t) - \\beta(t) \\Big)V\\] \\[\\frac{dV}{V} = \\Big(\\mu(t)  \\exp(-\\alpha t) - \\beta(t) \\Big)dt\\]\nNOTE that \\(\\mu(t)\\) and \\(\\beta(t)\\) are constants in this interval. Thus \\[\\ln(V) = \\frac{\\mu  \\exp(-\\alpha t)}{-\\alpha} - \\beta t +C_1\\] \\[V= \\exp\\Big(\\frac{\\mu  \\exp(-\\alpha t)}{-\\alpha} - \\beta t +C_1\\Big)\\] \\[V= C\\exp\\Big(\\frac{\\mu}{-\\alpha} \\exp(-\\alpha t) - \\beta t\\Big)\\]\nwe using the initial condition \\(V(0)=2\\) we have \\[V(0) = C\\exp\\Big(\\frac{-\\mu }{\\alpha} \\Big)\\] \\[2 = C\\exp\\Big(\\frac{-\\mu}{\\alpha}\\Big)\\] \\[C = 2\\exp\\Big(\\frac{\\mu}{\\alpha}\\Big)\\]\nThen, we have \\[C=296.8263\\]\nThus, the solution for the interval \\([0,15]\\) is \\[V(t) = 296.8263\\exp\\Big(\\frac{\\mu}{-\\alpha} \\exp(-\\alpha t)\\Big)\\] and \\(V(15)=296.8263\\exp\\Big(\\frac{\\mu}{-\\alpha} \\exp(-\\alpha 15)\\Big)=4.0132\\)\nwe calculated the general solution for the interval \\([0,15]\\), now we need to calculate the solution for the interval \\([15,30]\\). We have: \\[V= C_2\\exp\\Big(\\frac{\\mu}{-\\alpha} \\exp(-\\alpha t) - \\beta t\\Big)\\] \\[C_2=V\\exp\\Big(\\beta t + \\frac{\\mu}{\\alpha} \\exp(-\\alpha t)\\Big)\\]\nwith the initial condition \\(V(15)=4.0132\\), \\(\\mu=0.05\\), \\(\\beta=0.04\\) and \\(\\alpha=0.01\\) we have\n\\[C_2 = 540.8428\\]\nNow, we can calculate the solution for the interval \\([15,30]\\). We have: \\[V(t) = C_2\\exp\\Big(\\frac{\\mu}{-\\alpha} \\exp(-\\alpha t) - \\beta t\\Big)\\] \\[V(30)=4.01106\\]\nNow we need to calculate the solution for the interval \\([30,60]\\). We have: \\[C_2=V\\exp\\Big(\\beta t + \\frac{\\mu}{\\alpha} \\exp(-\\alpha t)\\Big)\\] with the initial condition \\(V(30)=4.01106\\), \\(\\mu=0.02\\), \\(\\beta=0.04\\) and \\(\\alpha=0.01\\) we have \\[C_3=58.59752\\] and\n\\[V(60)=1.7737\\]\nFinally, we need to calculate the solution for the interval \\([60,\\infty]\\). We have: \\(4C_4=17.6492\\)\nThus the general solution is\n\\[V(t) =\\begin{cases}\n296.8263\\exp\\Big(-5 \\exp(-0.01 t)\\Big), & \\text{si } t < 15 \\text{ días} \\\\\n540.8428\\exp\\Big(-5 \\exp(-0.01 t) - 0.04 t\\Big), & \\text{si } 15 \\text{ días} \\leq t < 30 \\text{ días} \\\\\n58.59752\\exp\\Big(-2 \\exp(-0.01 t) - 0.04 t\\Big), & \\text{si } 30 \\text{ días} \\leq t < 60 \\text{ días} \\\\\n17.64923\\exp\\Big(-2 \\exp(-0.01 t) - 0.02 t\\Big), & \\text{si } t \\geq 60 \\text{ días}\n\\end{cases}\\]"
  },
  {
    "objectID": "sol_taller.html#second-form-of-solution-using-sympy",
    "href": "sol_taller.html#second-form-of-solution-using-sympy",
    "title": "Untitled",
    "section": "second form of solution (using sympy)",
    "text": "second form of solution (using sympy)\nThese procedure is more easy than the first form, but we need to use sympy and it could be slow and in general problems could’t be solved.\n\nmu=0.05#sp.Piecewise((0.05,x<=30),(0.02,x>30))\nbeta=0.0#sp.Piecewise((0,x<=15),(0.04,x<=60),(0.02,x>60))\nalpha = 0.01\n# solucion de un edo\ny = sp.Function('y')\nF=(mu*sp.exp(-alpha*x)-beta)\nresult = sp.dsolve(sp.Derivative(y(x), x) -y(x)*F,ics={y(0):2})\nresult\n\n\\(\\displaystyle y{\\left(x \\right)} = 296.826318205153 e^{- 5.0 e^{- 0.01 x}}\\)\n\n\n\nv_15=result.rhs.subs(x,15)\nv_15\n\n\\(\\displaystyle 4.01327372462733\\)\n\n\n\nmu=0.05#sp.Piecewise((0.05,x<=30),(0.02,x>30))\nbeta=0.04#sp.Piecewise((0,x<=15),(0.04,x<=60),(0.02,x>60))\nalpha = 0.01\n# solucion de un edo\ny = sp.Function('y')\nF=(mu*sp.exp(-alpha*x)-beta)\nresult = sp.dsolve(sp.Derivative(y(x), x) -y(x)*F,ics={y(15):v_15})\nresult\n\n\\(\\displaystyle y{\\left(x \\right)} = 540.852814852304 e^{- 0.04 x - 5.0 e^{- 0.01 x}}\\)\n\n\n\nv_30=result.rhs.subs(x,30)\nv_30\n\n\\(\\displaystyle 4.01106213232898\\)\n\n\n\nmu=0.02#sp.Piecewise((0.05,x<=30),(0.02,x>30))\nbeta=0.04#sp.Piecewise((0,x<=15),(0.04,x<=60),(0.02,x>60))\nalpha = 0.01\n# solucion de un edo\ny = sp.Function('y')\nF=(mu*sp.exp(-alpha*x)-beta)\nresult = sp.dsolve(sp.Derivative(y(x), x) -y(x)*F,ics={y(30):v_30})\nresult\n\n\\(\\displaystyle y{\\left(x \\right)} = 58.5975284173285 e^{- 0.04 x - 2.0 e^{- 0.01 x}}\\)\n\n\n\nv_60=result.rhs.subs(x,60)\nv_60\n\n\\(\\displaystyle 1.7737026358928\\)\n\n\n\nmu=0.02#sp.Piecewise((0.05,x<=30),(0.02,x>30))\nbeta=0.02#sp.Piecewise((0,x<=15),(0.04,x<=60),(0.02,x>60))\nalpha = 0.01\n# solucion de un edo\ny = sp.Function('y')\nF=(mu*sp.exp(-alpha*x)-beta)\nresult = sp.dsolve(sp.Derivative(y(x), x) -y(x)*F,ics={y(30):v_60})\nresult\n\n\\(\\displaystyle y{\\left(x \\right)} = 14.2208000868479 e^{- 0.02 x - 2.0 e^{- 0.01 x}}\\)\n\n\nWe obtain the same solution."
  },
  {
    "objectID": "sol_taller.html#section",
    "href": "sol_taller.html#section",
    "title": "Untitled",
    "section": "2.",
    "text": "2.\nWe can analyze the flux of differential equation, e.d. the vector field \\(F(t,V)\\). NOTE the volume \\(V\\) always is positive, thus we only need to analyze when the function \\(\\mu(t)\\exp(-\\alpha t)-\\beta(t)>0\\), thus the graph of the function is\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef mu(t):\n    condiciones = [t < 30, t >= 30]\n    expresiones = [0.05, 0.02]\n\n    resultado = np.piecewise(t, condiciones, expresiones)\n    \n    return resultado\n\ndef beta(t):\n    condiciones = [t < 15, (t >= 15) & (t < 60),t >= 60]\n    expresiones = [0,0.04, 0.02]\n\n    resultado = np.piecewise(t, condiciones, expresiones)\n    \n    return resultado\n\nalpha = 0.01\n\ndef f(t):\n    return mu(t)*np.exp(-alpha*t)-beta(t)\ntspan = np.linspace(0, 80, 10000)\nplt.plot(tspan, F(tspan))\n\n\n\n\nHere we need to choose \\(t\\) such that \\(f(t)\\leq 0\\). Thus, we can use some method to find the root of the function \\(f(t)\\), in this sample we can use the bisection method into the interval \\([15,30]\\).\n\ndef mu(t):\n    if t < 30:\n        return 0.05\n    else:\n        return 0.02\n    \ndef beta(t):\n    if t < 15:\n        return 0\n    elif t < 60:\n        return 0.04\n    else:\n        return 0.02\n\n\ndef F(t):\n    return mu(t)*np.exp(-alpha*t)-beta(t) \n\n\n\n\ndef biseccion(F,a, b, tol, max_iter):\n    if f(a)*f(b) < 0:\n        i = 0\n        while i < max_iter:\n            c = (a + b)/2\n            if f(c) == 0 or (b - a)/2 < tol:\n                return c\n            i += 1\n            if f(a)*f(c) > 0:\n                a = c\n            else:\n                b = c\n        return c\n    else:\n        print(\"No hay raíz en el intervalo\",f(a),f(b))\n\nbiseccion(f,15,30,1e-15,200)    \n\n22.31435513142098\n\n\nThe flux is positive in the interval \\([0,22.314]\\)"
  },
  {
    "objectID": "sol_taller.html#cuándo-se-espera-que-el-volumen-del-tumor-alcanza-1.5-cm3-en-función-de-las-tasas-de-crecimiento-y-reducción-proporcionadas-por-las-funciones-mut-y-betat",
    "href": "sol_taller.html#cuándo-se-espera-que-el-volumen-del-tumor-alcanza-1.5-cm3-en-función-de-las-tasas-de-crecimiento-y-reducción-proporcionadas-por-las-funciones-mut-y-betat",
    "title": "Untitled",
    "section": "3. ¿Cuándo se espera que el volumen del tumor alcanza 1.5 \\(cm^3\\) en función de las tasas de crecimiento y reducción proporcionadas por las funciones \\(\\mu(t)\\) y \\(\\beta(t)\\)?",
    "text": "3. ¿Cuándo se espera que el volumen del tumor alcanza 1.5 \\(cm^3\\) en función de las tasas de crecimiento y reducción proporcionadas por las funciones \\(\\mu(t)\\) y \\(\\beta(t)\\)?\nWe can use the solution of the differential equation to calculate the time when the volume of the tumor is \\(1.5 cm^3\\), and create a new function to find the zero of function \\[g(t)=V(t)-1.5\\].\n\n\ng=lambda t: 17.64923*np.exp(-2*np.exp(-0.01*t)-0.02*t)-1.5\nbiseccion(g,60,80,1e-1,100000)\ntspan = np.linspace(60, 80, 10000)\nplt.plot(tspan, g(tspan))\n\n\nNo hay raíz en el intervalo -0.009023767278119472 -0.011013420717655568"
  },
  {
    "objectID": "sol_taller.html#si-suspende-el-tratamiento-entonces-alpha-0.1-y-betat0-cuándo-se-espera-que-el-volumen-del-tumor-alcance-17.5-cm3",
    "href": "sol_taller.html#si-suspende-el-tratamiento-entonces-alpha-0.1-y-betat0-cuándo-se-espera-que-el-volumen-del-tumor-alcance-17.5-cm3",
    "title": "Untitled",
    "section": "4. Si suspende el tratamiento entonces \\(\\alpha=-0.1\\) y \\(\\beta(t)=0\\), ¿cuándo se espera que el volumen del tumor alcance 17.5 \\(cm^3\\)?",
    "text": "4. Si suspende el tratamiento entonces \\(\\alpha=-0.1\\) y \\(\\beta(t)=0\\), ¿cuándo se espera que el volumen del tumor alcance 17.5 \\(cm^3\\)?"
  },
  {
    "objectID": "taller_entrega.html",
    "href": "taller_entrega.html",
    "title": "clases",
    "section": "",
    "text": "Imagina que estás trabajando en un proyecto de biomatemática para estudiar el crecimiento de tumores cancerosos en un órgano específico del cuerpo. Para modelar el crecimiento del tumor en función del tiempo, utilizas el modelo de Gompertz, que se expresa de la siguiente manera:\n\\[V(t)=V_0⋅e^{e^{(r⋅(T−t)+1)}}\\]\nDonde:\n\n\\(V(t)\\) es el volumen del tumor en función del tiempo \\(t\\).\n\\(V_0\\) es el volumen inicial del tumor en \\(t=0\\).\n\\(r\\) es la tasa de crecimiento del tumor.\n\\(T\\) es el tiempo en el que se detendría el crecimiento si no hubiera limitaciones.\n\nTu objetivo es determinar el valor de \\(T\\) para el cual el volumen del tumor alcanza un tamaño crítico o se estabiliza. En otras palabras, necesitas encontrar el valor de \\(T\\) para el cual \\(V(T)\\) es igual a un valor específico, como VcVc, que podría representar un umbral crítico o el tamaño de tumor objetivo."
  },
  {
    "objectID": "taller_entrega.html#introducción",
    "href": "taller_entrega.html#introducción",
    "title": "clases",
    "section": "Introducción",
    "text": "Introducción\nEstás trabajando en un proyecto de investigación biomatemática centrado en el crecimiento de un tumor maligno en un paciente con cáncer. Tu objetivo es modelar cómo evoluciona el tumor en respuesta a un tratamiento que varía con el tiempo. Utilizarás un modelo de crecimiento tumoral más complejo, el modelo de crecimiento tumoral con tratamiento, que involucra tasas de crecimiento variables y la administración de un tratamiento.\n\nEn el momento \\(t = 0\\), el volumen del tumor \\(V\\) es de \\(1 cm^3\\).\nLa tasa de crecimiento máxima del tumor, \\(\\mu(t)\\), varía con el tiempo.\nLa constante que controla la velocidad de disminución en la tasa de crecimiento, \\(\\alpha\\), es igual a 0.01.\nLa tasa de reducción del tumor debido al tratamiento, \\(\\beta(t)\\), también varía con el tiempo."
  },
  {
    "objectID": "taller1.html",
    "href": "taller1.html",
    "title": "clases",
    "section": "",
    "text": "Estás trabajando en un proyecto de investigación biomatemática centrado en el crecimiento de un tumor maligno en un paciente con cáncer. Tu objetivo es modelar cómo evoluciona el tumor en respuesta a un tratamiento que varía con el tiempo. Utilizarás un modelo de crecimiento tumoral más complejo, el modelo de crecimiento tumoral con tratamiento, que involucra tasas de crecimiento variables y la administración de un tratamiento.\n\nEn el momento \\(t = 0\\), el volumen del tumor \\(V\\) es de \\(1 cm^3\\).\nLa tasa de crecimiento máxima del tumor, \\(\\mu(t)\\), varía con el tiempo.\nLa constante que controla la velocidad de disminución en la tasa de crecimiento, \\(\\alpha\\), es igual a 0.01.\nLa tasa de reducción del tumor debido al tratamiento, \\(\\beta(t)\\), también varía con el tiempo."
  },
  {
    "objectID": "sistemas.html",
    "href": "sistemas.html",
    "title": "Solución de sistemas de ecuaciones lineales",
    "section": "",
    "text": "Solucionar un sistema de ecuaciones lineales es encontrar el valor de las variables que satisfacen todas las ecuaciones del sistema. En este capítulo se estudiarán los métodos de solución de sistemas de ecuaciones lineales.\nSea \\(A\\) una matriz de \\(n \\times n\\) y \\(b\\) un vector de \\(n \\times 1\\). El sistema de ecuaciones lineales \\(Ax = b\\) se puede escribir como:\n\\[\\begin{bmatrix}a_{1,1}&a_{1,2}\\dots&a_{1,n}\\\\\na_{2,1}&a_{2,2}\\dots&a_{2,n}\\\\\n\\vdots&\\vdots&\\ddots&\\vdots\\\\\na_{n,1}&a_{n,2}\\dots&a_{n,n}\\\\\n\\end{bmatrix}\\begin{bmatrix}x_1\\\\x_2\\\\\\vdots\\\\x_n\\end{bmatrix}=\\begin{bmatrix}b_1\\\\b_2\\\\\\vdots\\\\b_n\\end{bmatrix}\\]\nDefiniremos \\(A_{\\cdot,j}\\) como la columna \\(j\\) de la matriz \\(A\\) y \\(A_{i,\\cdot}\\) como la fila \\(i\\) de la matriz \\(A\\).\n\n\nSea \\(A\\) una matriz triangular superior de \\(n \\times n\\) y \\(b\\) un vector de \\(n \\times 1\\). El sistema de ecuaciones lineales \\(Ax = b\\) se puede escribir como:\n\\[\\begin{bmatrix}a_{1,1}&a_{1,2}\\dots&a_{1,n}\\\\\n0&a_{2,2}\\dots&a_{2,n}\\\\\n\\vdots&\\vdots&\\ddots&\\vdots\\\\\n0&0\\dots&a_{n,n}\\\\\n\\end{bmatrix}\\begin{bmatrix}x_1\\\\x_2\\\\\\vdots\\\\x_n\\end{bmatrix}=\\begin{bmatrix}b_1\\\\b_2\\\\\\vdots\\\\b_n\\end{bmatrix}\\]\nEl sistema de ecuaciones lineales se puede resolver por sustitución hacia atrás. El algoritmo para resolver el sistema de ecuaciones lineales es:\n\nInicializar \\(x_n = \\frac{b_n}{a_{n,n}}\\).\nPara \\(i = n-1, n-2, \\dots, 1\\):\n\nCalcular \\(x_i = \\frac{b_i - \\sum_{j=i+1}^n a_{i,j}x_j}{a_{i,i}}\\).\n\n\nSea \\(A\\) una matriz triangular inferior de \\(n \\times n\\) y \\(b\\) un vector de \\(n \\times 1\\). El sistema de ecuaciones lineales \\(Ax = b\\) se puede escribir como:\n\\[\\begin{bmatrix}a_{1,1}&0\\dots&0\\\\\na_{2,1}&a_{2,2}\\dots&0\\\\\n\\vdots&\\vdots&\\ddots&\\vdots\\\\\na_{n,1}&a_{n,2}\\dots&a_{n,n}\\\\\n\\end{bmatrix}\\begin{bmatrix}x_1\\\\x_2\\\\\\vdots\\\\x_n\\end{bmatrix}=\\begin{bmatrix}b_1\\\\b_2\\\\\\vdots\\\\b_n\\end{bmatrix}\\]\nEl sistema de ecuaciones lineales se puede resolver por sustitución hacia adelante. El algoritmo para resolver el sistema de ecuaciones lineales es:\n\nInicializar \\(x_1 = \\frac{b_1}{a_{1,1}}\\).\nPara \\(i = 2, 3, \\dots, n\\):\n\nCalcular \\(x_i = \\frac{b_i - \\sum_{j=1}^{i-1} a_{i,j}x_j}{a_{i,i}}\\)."
  },
  {
    "objectID": "sistemas.html#algoritmo-de-factorización-lu",
    "href": "sistemas.html#algoritmo-de-factorización-lu",
    "title": "Solución de sistemas de ecuaciones lineales",
    "section": "Algoritmo de factorización LU",
    "text": "Algoritmo de factorización LU\nEl algoritmo de factorización LU es el siguiente:\n\nInicializar \\(L = I\\) y \\(U = A\\).\nPara \\(i = 1, 2, \\dots, n-1\\):\n\nPara \\(j = i+1, i+2, \\dots, n\\):\n\nCalcular \\(L_{j,i} = \\frac{U_{j,i}}{U_{i,i}}\\).\nPara \\(k = i, i+1, \\dots, n\\):\n\nCalcular \\(U_{j,k} = U_{j,k} - L_{j,i}U_{i,k}\\).\n\n\n\n\nEjemplo en pyrhon\nimport numpy as np\n## algortimo LU\ndef LU(A):\n    n = A.shape[0]\n    L = np.eye(n)\n    U = A.copy()\n    for i in range(n-1):\n        for j in range(i+1, n):\n            L[j,i] = U[j,i]/U[i,i]\n            for k in range(i, n):\n                U[j,k] = U[j,k] - L[j,i]*U[i,k]\n    return L, U\nNote De forma vectorial podemos escribir el algoritmo de la siguiente forma:\n\n## algortimo LU\nimport numpy as np\n\ndef LU(A):\n    n = A.shape[0]\n    L = np.eye(n)\n    U = A.copy()\n    \n    for i in range(n - 1):\n        L[i+1:, i] = U[i+1:, i] / U[i, i]\n        U[i+1:, i:] -= np.outer(L[i+1:, i], U[i, i:])\n    \n    return L, U"
  },
  {
    "objectID": "sistemas.html#pivotación-parcial",
    "href": "sistemas.html#pivotación-parcial",
    "title": "Solución de sistemas de ecuaciones lineales",
    "section": "Pivotación parcial",
    "text": "Pivotación parcial\nLa pivotación parcial es un método para evitar que el algoritmo de factorización LU falle. La pivotación parcial consiste en intercambiar filas de la matriz \\(A\\) de tal forma que el elemento de la diagonal que se está utilizando para calcular los multiplicadores de la columna sea el mayor posible.\nEl algoritmo de factorización LU con pivotación parcial es el siguiente:\n\nInicializar \\(L = I\\) y \\(U = A\\).\nPara \\(i = 1, 2, \\dots, n-1\\):\n\nEncontrar \\(j\\) tal que \\(|U_{j,i}| = \\max_{k=i, i+1, \\dots, n} |U_{k,i}|\\).\nIntercambiar las filas \\(i\\) y \\(j\\) de \\(U\\) y \\(L\\).\nPara \\(j = i+1, i+2, \\dots, n\\):\n\nCalcular \\(L_{j,i} = \\frac{U_{j,i}}{U_{i,i}}\\).\nPara \\(k = i, i+1, \\dots, n\\):\n\nCalcular \\(U_{j,k} = U_{j,k} - L_{j,i}U_{i,k}\\)."
  },
  {
    "objectID": "sistemas.html#algortimo-lu-con-pivotación-parcial",
    "href": "sistemas.html#algortimo-lu-con-pivotación-parcial",
    "title": "Solución de sistemas de ecuaciones lineales",
    "section": "algortimo LU con pivotación parcial",
    "text": "algortimo LU con pivotación parcial\n\nimport numpy as np\n\ndef LU_partial_pivot(A):\n    n = A.shape[0]\n    L = np.eye(n)\n    U = A.copy()\n    P = np.eye(n)\n\n    for i in range(n - 1):\n        pivot_row = np.argmax(np.abs(U[i:, i])) + i\n        \n        if pivot_row != i:\n            U[[i, pivot_row]] = U[[pivot_row, i]]\n            P[[i, pivot_row]] = P[[pivot_row, i]]\n            \n            if i > 0:\n                L[[i, pivot_row], :i] = L[[pivot_row, i], :i]\n\n        L[i+1:, i] = U[i+1:, i] / U[i, i]\n        U[i+1:, i:] -= np.outer(L[i+1:, i], U[i, i:])\n    \n    return P, L, U\n\nVentajas del pivoteo parcial:\n\nEstabilidad numérica Ayuda a prevenir errores de redondeo y la propagación de errores en el cálculo numérico.\nPrevención de divisiones por cero\nMayor robustez\nEficiencia en sistemas grandes Aunque el pivoteo parcial puede aumentar la cantidad de operaciones realizadas en comparación con el pivoteo simple (sin pivoteo), en sistemas grandes, los beneficios en términos de estabilidad numérica superan con creces el costo adicional computacional.\n\n\nEjercicios\n\nEncuentre la factorización LU a mano de \\[A=\\left(\\begin{array}{ccc}\n  1&-3&0\\\\\n-1&0&-9\\\\\n4&6&0\n\\end{array}\\right),\n\\]\nLa siguiente matriz no tiene inversa, por tanto no tiene factorizacion LU única, encuentre dos factorizaciones diferentes de la matriz \\[A=\\left(\\begin{array}{ccc}\n1&-3&0\\\\\n  -2&0&-9\\\\\n  1&3&9\n  \\end{array}\\right),\n\\]\nSea el sistema\n\n\\[\\begin{cases}\n     10^{-14}x+y&=1\\\\\n     x+y&=2\n    \\end{cases}\n\\]\na.  Grafique cada ecuación en un mismo plano cartesiano. ¿Observa algo particular en la gráfica?\n\nb. Resuelva el  sistema de ecuaciones exactamente\n\nc.  Resuelva el sistema de ecuaciones sin usar Pivoteo por medio de LU\n\nd.  Resuelva el  sistema de ecuaciones usando Pivoteo por medio de LU\n\ne.  Observe las soluciones anteriores, realice una comparación entre ellas ¿Que puede observa? De una conclusión del porque hay tienen diferentes respuestas.\n\nSea la matriz (use format short) \\[A=\\left(\\begin{array}{ccc}\n  1276929.38 &-930737.61&-617.4\\\\\n  −1930737.61 & 3316209.17&1755.3\\\\\n  −617.4& 1755.3&2\n  \\end{array}\\right),\n  b=\\left(\\begin{array}{c}2\\\\1\\\\3\\end{array}\\right)\n\\]\n\nResuelva el siguiente sistema de ecuaciones \\(Ax=b\\) sin usar Pivoteo por medio de LU\nResuelva el siguiente sistema de ecuaciones \\(Ax=b\\) usando Pivoteo por medio de LU\nObserve las soluciones anteriores, compruebe la solución de la forma \\(b-A*x\\), realice una comparación entre ellas ¿Que puede observar?\n\nUsando la factorización LU, escriba un pseudocódigo para encontrar la inversa de una matriz. Prográmelo.\nPara calcular el esfuerzo de una viga normalmente se tiene que resolver un sistema de ecuaciones de la forma \\[\\left(\\begin{array}{cccccccc}\n4&2&1\\\\\n2&4&2&1\\\\\n1&2&4&2&1\\\\\n&1&2&4&2&1\\\\\n&&1&2&4&2&1\\\\\n&&&1&2&4&2\\\\\n&&&&1&2&4\\\\\n  \\end{array}\\right)\\left(\\begin{array}{c}\n                  x_1\\\\x_2\\\\x_3\\\\x_4\\\\x_5\\\\x_6\\\\x_7\n                 \\end{array}\\right)=\\left(\\begin{array}{c}\n                  4\\\\1\\\\1\\\\1\\\\1\\\\1\\\\4\n                 \\end{array}\\right)\n\\]\n\n\n¿Para resolver este sistema de ecuaciones que método usaría?\nUsando el programa de LU sin pivoteo encuentre la inversa de la matriz\nUsando el programa de LU con pivoteo encuentre la inversa de la matriz\nUsando el programa de Cholesky encuentre la inversa de la matriz\n¿Cual de los métodos requiere menos esfuerzo computacional? Compare su respuesta con las del punto a.\n\n\nSea la siguiente matriz, Note que ella es simétrica y se puede probar que es definida positiva\n\n\\[\\begin{bmatrix}\n1&1/2&1/3&1/4&1/5&1/6&1/7&1/8&1/9&1/10\\\\\n1/2&1/3&1/4&1/5&1/6&1/7&1/8&1/9&1/10&1/11\\\\\n1/3&1/4&1/5&1/6&1/7&1/8&1/9&1/10&1/11&1/13\\\\\n1/4&1/5&1/6&1/7&1/8&1/9&1/10&1/11&1/13&1/14\\\\\n1/5&1/6&1/7&1/8&1/9&1/10&1/11&1/13&1/14&1/15\\\\\n1/6&1/7&1/8&1/9&1/10&1/11&1/13&1/14&1/15&1/16\\\\\n1/7&1/8&1/9&1/10&1/11&1/13&1/14&1/15&1/16&1/17\\\\\n1/8&1/9&1/10&1/11&1/13&1/14&1/15&1/16&1/17&1/18\\\\\n1/9&1/10&1/11&1/13&1/14&1/15&1/16&1/17&1/18&1/19\\\\\n1/10&1/11&1/13&1/14&1/15&1/16&1/17&1/18&1/19&1/20\\\\\n\\end{bmatrix}\\begin{bmatrix}\n                     x_1\\\\x_2\\\\x_3\\\\x_4\\\\x_5\\\\x_6\\\\x_7\\\\x_8\\\\x_9\\\\x_{10}\n                    \\end{bmatrix}=\\begin{bmatrix}\n                     4\\\\1\\\\1\\\\1\\\\1\\\\1\\\\1\\\\1\\\\1\\\\3\n                    \\end{bmatrix}\\]\nPara obtener esta matriz puede usar desde scipy.linalg la función hilbert\n\nResuelva el sistema usando Cholescky y compruebe su respuesta\nresuelva el sistema usando LU y compruebe su respuesta\ncompre las dos repuestas. ¿Son diferentes?\nRepita esta proceso con hilbert(1000), ¿que pasa? ¿Por que cree que sucede esto?"
  },
  {
    "objectID": "sistemas.html#número-de-condición-de-una-matriz",
    "href": "sistemas.html#número-de-condición-de-una-matriz",
    "title": "Solución de sistemas de ecuaciones lineales",
    "section": "Número de condición de una matriz",
    "text": "Número de condición de una matriz\nSea \\(A\\) una matriz cuadrada de \\(n \\times n\\), notamos como \\(\\|A\\|\\) la norma de la matriz \\(A\\) y \\(\\|A^{-1}\\|\\) es la norma de la matriz inversa de \\(A\\).\nTeorema Si \\(A\\) es una matriz invertible, entonces \\(\\kappa_2(A) = \\frac{\\lambda_{\\max}(A)}{\\lambda_{\\min}(A)}\\), donde \\(\\lambda_{\\max}(A)\\) es el mayor valor propio de \\(A\\) y \\(\\lambda_{\\min}(A)\\) es el menor valor propio de \\(A\\).\nFactor de error de magnificación El factor de error de magnificación es una medida de la magnitud del error relativo en la solución de un sistema de ecuaciones lineales, \\(Ax=b\\). El factor de error de magnificación se define como:\nSea \\(x_a\\) la solución aproximada del sistema de ecuaciones lineales \\(Ax=b\\) y \\(x\\) la solución exacta del sistema de ecuaciones lineales \\(Ax=b\\). El residual se define como \\(r = b - Ax_a\\). El error hacia atrás es la norma del residual \\(\\|r\\|=\\|b-Ax\\|\\). El error hacia adelante es la norma de la diferencia entre la solución aproximada y la solución exacta \\(\\|x_a - x\\|\\).\nEjemplo\nEncontrar el error hacia adelante y el error hacia atrás para la solución aproximada \\(x_a=[1,1]\\) del sistema\n\\[\\begin{bmatrix}1&1\\\\3&-4\\end{bmatrix}\\begin{bmatrix}x_1\\\\x_2\\end{bmatrix}=\\begin{bmatrix}3\\\\2\\end{bmatrix}\\] + Encuentre la solución exacta del sistema de ecuaciones lineales. \\([2,1]\\) + Encuentre el error hacia atrás. + Encuentre el error hacia adelante. Ejemplo Encuentre los errores hacia adelante y hacia atrás para la solución aproximada \\(x_a=[−1, 3.0001]\\) de el sistema\n\\[\\begin{bmatrix}1&1\\\\1.0001&1\\end{bmatrix}\\begin{bmatrix}x_1\\\\x_2\\end{bmatrix}=\\begin{bmatrix}2\\\\2.0001\\end{bmatrix}\\] + Encuentre la solución exacta del sistema de ecuaciones lineales, \\([1,1]\\) + Encuentre el error hacia atrás. + Encuentre el error hacia adelante. Resolviendo el sistema tenemos \\[x =[1,1]\\]\nDefinición Denotamos el error relativo hacia atrás como \\(\\frac{\\|r\\|}{\\|b\\|}\\) y el error relativo hacia adelante como \\(\\frac{\\|x_a - x\\|}{\\|x\\|}\\).\nUsando la anteriro definición podemos introducir el concepto de factor de error de magnificación. El factor de error de magnificación es una medida de la magnitud del error relativo en la solución de un sistema de ecuaciones lineales, \\(Ax=b\\). El factor de error de magnificación se define como:\n\\[factor\\ magnificación\\ error=\\frac{error_{realitco\\ hacia\\ delante}}{error_{realitco\\ hacia\\  atras}}=\\frac{\\frac{||x-x_a||_{\\infty}}{||x||_\\infty}}{\\frac{||r||_\\infty}{||b||_\\infty}}\\]\nen el sistema anterior tenemos que \\[40004.0001\\%\\]\nEl número de condición de una matriz es una medida de la sensibilidad de la solución de un sistema de ecuaciones lineales a pequeños cambios en los coeficientes de las ecuaciones. El número de condición de una matriz se define como:\n\\[\\kappa(A) = \\|A\\| \\|A^{-1}\\|\\]\nEl numero de condición de una matriz cuadrada se puede interpretar como el máximo factor de ampliación del error posible para resolver \\(Ax = b\\), sobre todos los lados derechos \\(b\\).\nEjemplo Calculemos el numero de condición de la matriz \\[\\begin{bmatrix}1&1\\\\1.0001&1\\end{bmatrix}\\]\n\nimport numpy as np\n\n# Define the matrix\nA = np.array([[1, 1], [1.0001, 1]])\n\n# Calculate the condition number\ncond = np.linalg.cond(A)\n\nprint(\"The condition number of the matrix is:\", cond)\n\nThe condition number of the matrix is: 40002.00007489988\n\n\nEl significado del número de condición es el mismo que en el Capítulo 1. Error de factor de magnificación de una magnitud \\(cond( A)\\) son posibles. En aritmética de coma flotante, No se puede esperar que el error relativo hacia atrás sea menor que \\(\\in_{mach}\\), ya que almacenar las entradas de \\(b\\) ya causan errores de ese tamaño. Según el factor de magnificación, la fuerza relativa Son posibles errores de tamaño \\(\\in_{mach}\\cdot cond(A)\\) al resolver \\(Ax = b\\). En otras palabras, si \\(cond(A) \\aprox 10^k\\), deberíamos prepararnos para perder \\(k\\) dígitos de precisión al calcular \\(x\\)."
  },
  {
    "objectID": "cholesky.html",
    "href": "cholesky.html",
    "title": "clases",
    "section": "",
    "text": "Una matriz \\(A\\) es definida positiva si \\(x^TAx > 0\\) para todo \\(x \\neq 0\\).\n\n\n\n\nUna matriz definida positiva es simétrica.\nUna matriz definida positiva tiene todos sus valores propios positivos.\nUna matriz definida positiva tiene todos sus menores principales positivos.\n\n\n\n\nLa matriz \\(A = \\begin{bmatrix} 1 & 2 \\\\ 2 & 5 \\end{bmatrix}\\) es definida positiva.\n\n\n\nEl algoritmo de Cholesky es un método para calcular la factorización de Cholesky de una matriz definida positiva.\nSea \\(A\\) una matriz simetrica definida positiva de orden \\(n\\). Entonces, existe una matriz triangular inferior \\(G\\) con elementos reales positivos en la diagonal tal que \\(A = GG^T\\). Para encontrar \\(G\\), se procede de la siguiente manera:\nSea la matriz \\[G=\\begin{bmatrix} g_{11} & 0 & \\cdots & 0 \\\\ g_{21} & g_{22} & \\cdots & 0 \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ g_{n1} & g_{n2} & \\cdots & g_{nn} \\end{bmatrix}\\]\nEntonces, \\(A = GG^T\\) implica que\n\\[\\begin{bmatrix} a_{11} & a_{12} & \\cdots & a_{1n} \\\\ a_{21} & a_{22} & \\cdots & a_{2n} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ a_{n1} & a_{n2} & \\cdots & a_{nn} \\end{bmatrix} = \\begin{bmatrix} g_{11}^2 & g_{11}g_{21} & \\cdots & g_{11}g_{n1} \\\\ g_{11}g_{21} & g_{21}^2 + g_{22}^2 & \\cdots & g_{21}g_{n1} + g_{22}g_{n2} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ g_{11}g_{n1} & g_{21}g_{n1} + g_{22}g_{n2} & \\cdots & g_{n1}^2 + g_{n2}^2 + \\cdots + g_{nn}^2 \\end{bmatrix}\\]\nde esta forma tenemos que\n\\[g_{11}^2 = a_{11} \\Rightarrow g_{11} = \\sqrt{a_{11}}\\] \\[g_{11}g_{21} = a_{12} \\Rightarrow g_{21} = \\frac{a_{12}}{g_{11}}\\]\n\\[\\vdots\\]\n\\[g_{11}g_{n1} = a_{1n} \\Rightarrow g_{n1} = \\frac{a_{1n}}{g_{11}}\\]\nAhora debemos calcular los elementos de la segunda fila de \\(G\\).\n\\[g_{21}^2 + g_{22}^2 = a_{22} \\Rightarrow g_{22} = \\sqrt{a_{22} - g_{21}^2}\\]\n\\[g_{21}g_{n1} + g_{22}g_{n2} = a_{2n} \\Rightarrow g_{n2} = \\frac{a_{2n} - g_{21}g_{n1}}{g_{22}}\\]\nVentajas dela algoritmod e Cholesky\n\nEl algoritmo de Cholesky es una técnica importante en álgebra lineal numérica.\nSe utiliza para factorizar una matriz simétrica definida positiva en el producto de una matriz triangular inferior y su traspuesta.\nEsta factorización tiene aplicaciones en la resolución de sistemas de ecuaciones lineales y la estimación de covarianzas en estadísticas.\nEl algoritmo de Cholesky es aproximadamente el doble de eficiente que la eliminación gaussiana para resolver sistemas de ecuaciones lineales.\nTambién es más estable numéricamente.\n\n\n\n\nimport numpy as np\ndef cholesky_decomposition(A): n = len(A) L = np.zeros_like(A)\nfor i in range(n):\n    for j in range(i + 1):\n        if i == j:\n            temp = A[i, i] - np.sum(L[i, :i] ** 2)\n            L[i, i] = np.sqrt(temp) if temp > 0 else 0.0\n        else:\n            L[i, j] = (A[i, j] - np.sum(L[i, :j] * L[j, :j])) / L[j, j]\n\nreturn L\nA = np.array([[4, 2, 2], [2, 5, 5], [2, 5, 9]]) L = cholesky_decomposition(A)"
  },
  {
    "objectID": "cholesky.html#propiedades",
    "href": "cholesky.html#propiedades",
    "title": "clases",
    "section": "Propiedades",
    "text": "Propiedades\n\nUna matriz definida positiva es simétrica.\nUna matriz definida positiva tiene todos sus valores propios positivos.\nUna matriz definida positiva tiene todos sus menores principales positivos."
  },
  {
    "objectID": "cholesky.html#ejemplo",
    "href": "cholesky.html#ejemplo",
    "title": "clases",
    "section": "Ejemplo",
    "text": "Ejemplo\nLa matriz \\(A = \\begin{bmatrix} 1 & 2 \\\\ 2 & 5 \\end{bmatrix}\\) es definida positiva."
  },
  {
    "objectID": "cholesky.html#algoritmo",
    "href": "cholesky.html#algoritmo",
    "title": "clases",
    "section": "Algoritmo",
    "text": "Algoritmo\nEl algoritmo de Cholesky es un método para calcular la factorización de Cholesky de una matriz definida positiva.\n\nEl algoritmo de Cholesky es una técnica importante en álgebra lineal numérica.\nSe utiliza para factorizar una matriz simétrica definida positiva en el producto de una matriz triangular inferior y su traspuesta.\nEsta factorización tiene aplicaciones en la resolución de sistemas de ecuaciones lineales y la estimación de covarianzas en estadísticas.\nEl algoritmo de Cholesky es aproximadamente el doble de eficiente que la eliminación gaussiana para resolver sistemas de ecuaciones lineales.\nTambién es más estable numéricamente."
  },
  {
    "objectID": "cholesky.html#algoritmo-de-cholesky",
    "href": "cholesky.html#algoritmo-de-cholesky",
    "title": "clases",
    "section": "Algoritmo de Cholesky",
    "text": "Algoritmo de Cholesky\nimport numpy as np\ndef cholesky_decomposition(A): n = len(A) L = np.zeros_like(A)\nfor i in range(n):\n    for j in range(i + 1):\n        if i == j:\n            temp = A[i, i] - np.sum(L[i, :i] ** 2)\n            L[i, i] = np.sqrt(temp) if temp > 0 else 0.0\n        else:\n            L[i, j] = (A[i, j] - np.sum(L[i, :j] * L[j, :j])) / L[j, j]\n\nreturn L\nA = np.array([[4, 2, 2], [2, 5, 5], [2, 5, 9]]) L = cholesky_decomposition(A)"
  },
  {
    "objectID": "borradores.html",
    "href": "borradores.html",
    "title": "clases",
    "section": "",
    "text": "import numpy as np\nfrom scipy.sparse import coo_matrix\nimport matplotlib.pyplot as plt\n\n# Generar una matriz dispersa grande de 1000x1000\nn = 1000\nnum_elementos_no_nulos = 1000  # Número de elementos no nulos\n\n# Generar datos aleatorios para los elementos no nulos\ndata = np.random.rand(num_elementos_no_nulos)\n\n# Generar índices de fila y columna aleatorios para los elementos no nulos\nrow_indices = np.random.randint(0, n, num_elementos_no_nulos)\ncolumn_indices = np.random.randint(0, n, num_elementos_no_nulos)\n\nsparse_matrix = coo_matrix((data, (row_indices, column_indices)), shape=(n, n))\n\n# Visualizar la matriz dispersa como un mapa de calor\nplt.figure(figsize=(8, 8))\nplt.spy(sparse_matrix, markersize=1)\nplt.title('Matriz Dispersa Grande')\nplt.show()"
  },
  {
    "objectID": "Gauss-seidel.html",
    "href": "Gauss-seidel.html",
    "title": "Jacobi y Gauss-Seidel",
    "section": "",
    "text": "El método de Gauss-Seidel es un método iterativo para resolver sistemas de ecuaciones lineales. El método consiste en despejar una variable de una ecuación y sustituirla en otra ecuación. Este proceso se repite hasta que se obtiene una solución aproximada.\nPara deducir el método de Gauss-Seidel, se parte de un sistema de ecuaciones lineales de la forma:\n\\[Ax = b\\] donde la matriz \\(A\\) es una matriz cuadrada de \\(n \\times n\\), \\(x\\) es un vector de \\(n\\) elementos y \\(b\\) es un vector de \\(n\\) elementos. De esta forma la matriz \\(A\\) se puede descomponer en la suma de dos matrices \\(D\\) y \\(M\\) de la siguiente forma:\n\\[A = L+D+U\\] donde \\(D\\) es la matriz de los elementos de la diagonal y \\(L\\) es la matriz triangular estrictamente inferior con \\(a_{ij}=l_{ij}\\) si \\(i>j\\) y \\(l_{ii}=0\\) y \\(U\\) es la matriz estrictamente triangular superior, es decir \\(a_{ij}=u_{ij}\\) si \\(i<j\\) y \\(u_{ii}=0\\) . De esta forma, el sistema de ecuaciones se puede reescribir como:\n\\[Dx = b - (L+U)x\\] De esta forma podemos crear un método iterativo de la forma \\[x^{n+1} = D^{-1}(b - (L+U)x^n)\\]\nEl método de Jacobi es una generalización del método del punto fijo. Los críterios de convergencia de este método es\nPseudocódigo\nDados \\(A_{n\\times n}\\) y \\(b_{n\\times 1}\\), max_iteraciones, tolerancia y \\(x_0\\):\nPara k=0,1,2,…,max_iteraciones:\nEjercicio observe el siguietne código si es necesario,comente cada línea de código, compruebe que corresponde al pseudocódigo anterior (en caso contrario realice los respectivos cambios) y ejecute el código."
  },
  {
    "objectID": "Gauss-seidel.html#teorema",
    "href": "Gauss-seidel.html#teorema",
    "title": "Jacobi y Gauss-Seidel",
    "section": "Teorema",
    "text": "Teorema\nUn método iterativo de la forma \\(x^{k+1}=Bx^k+c\\) converge si y solo si \\(\\rho(B)<1\\), donde \\(\\rho(B)\\) es el radio espectral de \\(B\\)., en otras palabras, el método converge si \\[max_{\\lambda \\in \\sigma(B)}|\\lambda|<1,\\] donde \\(\\lambda\\) es un autovalor de \\(B\\) y \\(\\sigma(B)\\) es el conjunto de autovalores de \\(B\\)."
  },
  {
    "objectID": "Gauss-seidel.html#convergencia-de-los-métodos",
    "href": "Gauss-seidel.html#convergencia-de-los-métodos",
    "title": "Jacobi y Gauss-Seidel",
    "section": "Convergencia de los métodos",
    "text": "Convergencia de los métodos\nMostrar que que un método converge no es simple, pero podemos establecer algunos criterios para determinar si un método converge o no.\n\nLo métodos iterativos de Jacobi y Gauss-Seidel convergen si la matriz \\(A\\) es diagonal dominante, es decir que el valor absoluto de la diagonal debe ser mayor que la suma de los valores absolutos de los elementos de la fila. \\[|a_{ii}| > \\sum_{j=1, j \\neq i}^{n} |a_{ij}|\\]\nSi la matriz \\(A\\) es simétrica y definida positiva, entonces el método de Gauss-Seidel converge.\n\nNote un sistema puede converger usando Jacobi o Gauss-Seidel pero podría no satisfacer alguno de estos criterios.\nEjercicio\nSea el siguiente sistema\n\\[\\begin{bmatrix} 8 & 2 & 1 \\\\ 5 & 4 & 1 \\\\ 4 & 3 & 4 \\end{bmatrix} \\begin{bmatrix} x_1 \\\\ x_2 \\\\ x_3 \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ 5 \\\\ 3 \\end{bmatrix}\\] + Muestre que la matriz \\(A\\) no es diagonal dominante. + Muestre que la matriz \\(A\\) no es simétrica y definida positiva.\n\nEncuentre la matriz \\(B\\) para el método de Jacobi y Gauss-Seidel, y encuentre el radio espectral de \\(B\\), para cada caso.\n¿El método de Jacobi converge? ¿El método de Gauss-Seidel converge?\n\nEjercicio\nSea el siguiente sistema\n\\[Ax=b\\]\ndonde\n\\[A=\\begin{bmatrix} 5&1&1&0&0&0&0&0\\\\1&5&1&1&0&0&0&0\\\\1&1&5&1&1&0&0&0\\\\0&1&1&5&1&1&0&0\\\\\n0&0&1&1&5&1&1&0\\\\0&0&0&1&1&5&1&1\\\\\n0&0&0&0&1&1&5&1\\\\\n0&0&0&0&0&1&1&5\\\\ \\end{bmatrix}\\]"
  },
  {
    "objectID": "jacobi.html",
    "href": "jacobi.html",
    "title": "clases",
    "section": "",
    "text": "import numpy as np\n\ndef jacobi(A, b, x0, tol, max_iter):\n    n = len(b)\n    x = x0.copy()\n    iter_count = 0\n    \n    while iter_count < max_iter:\n        iter_count += 1\n        new_x = np.zeros(n)\n        \n        for i in range(n):\n            sum_ = 0\n            for j in range(n):\n                if j != i:\n                    sum_ += A[i][j] * x[j]\n            new_x[i] = (b[i] - sum_) / A[i][i]\n        \n        # Comprobar convergencia\n        if np.all(np.abs(x - new_x) < tol):\n            return new_x\n        \n        x = new_x.copy()\n    \n    raise Exception(\"El método de Jacobi no convergió después de {} iteraciones.\".format(max_iter))\n\n# Matriz de coeficientes A y vector de términos constantes b\nA = np.array([[3, 1, -1],\n              [1, 4, 1],\n              [2, -1, 3]])\n\nb = np.array([1, 5, 3])\n\n# Estimación inicial\nx0 = np.array([0, 0, 0])\n\n# Tolerancia y número máximo de iteraciones\ntolerancia = 1e-6\nmax_iteraciones = 1000\n\n# Llamada a la función para resolver el sistema\nsolucion = jacobi(A, b, x0, tolerancia, max_iteraciones)\n\n# Imprimir la solución\nprint(\"La solución aproximada es:\", solucion)"
  },
  {
    "objectID": "Gauss-seidel2.html",
    "href": "Gauss-seidel2.html",
    "title": "Jacobi y Gauss-Seidel",
    "section": "",
    "text": "El método de Gauss-Seidel es un método iterativo para resolver sistemas de ecuaciones lineales. El método consiste en despejar una variable de una ecuación y sustituirla en otra ecuación. Este proceso se repite hasta que se obtiene una solución aproximada.\nPara deducir el método de Gauss-Seidel, se parte de un sistema de ecuaciones lineales de la forma:\n\\[Ax = b\\] donde la matriz \\(A\\) es una matriz cuadrada de \\(n \\times n\\), \\(x\\) es un vector de \\(n\\) elementos y \\(b\\) es un vector de \\(n\\) elementos. De esta forma la matriz \\(A\\) se puede descomponer en la suma de dos matrices \\(D\\) y \\(M\\) de la siguiente forma:\n\\[A = L+D+U\\] donde \\(D\\) es la matriz de los elementos de la diagonal y \\(L\\) es la matriz triangular estrictamente inferior con \\(a_{ij}=l_{ij}\\) si \\(i>j\\) y \\(l_{ii}=0\\) y \\(U\\) es la matriz estrictamente triangular superior, es decir \\(a_{ij}=u_{ij}\\) si \\(i<j\\) y \\(u_{ii}=0\\) . De esta forma, el sistema de ecuaciones se puede reescribir como:\n\\[Dx = b - (L+U)x\\] De esta forma podemos crear un método iterativo de la forma \\[x^{n+1} = D^{-1}(b - (L+U)x^n)\\]\nEl método de Jacobi es una generalización del método del punto fijo. Los críterios de convergencia de este método es\nPseudocódigo\nDados \\(A_{n\\times n}\\) y \\(b_{n\\times 1}\\), max_iteraciones, tolerancia y \\(x_0\\):\nPara k=0,1,2,…,max_iteraciones:\n\\[x_i^{k+1} = \\frac{1}{a_{ii}}(b_i - \\sum_{j=1, j \\neq i}^{n} a_{ij}x_j^k)\\]\nsi \\(||x^{k+1} - x^k||\\) < tolerancia$ para todo \\(i=1,2,...,n\\): Imprima la solución y detenga el algoritmo sino \\[x^k = x^{k+1}\\]\nEjercicio observe el siguietne código si es necesario,comente cada línea de código, compruebe que corresponde al pseudocódigo anterior (en caso contrario realice los respectivos cambios) y ejecute el código."
  },
  {
    "objectID": "Gauss-seidel2.html#teorema",
    "href": "Gauss-seidel2.html#teorema",
    "title": "Jacobi y Gauss-Seidel",
    "section": "Teorema",
    "text": "Teorema\nUn método iterativo de la forma \\(x^{k+1}=Bx^k+c\\) converge si y solo si \\(\\rho(B)<1\\), donde \\(\\rho(B)\\) es el radio espectral de \\(B\\)., en otras palabras, el método converge si \\[max_{\\lambda \\in \\sigma(B)}|\\lambda|<1,\\] donde \\(\\lambda\\) es un autovalor de \\(B\\) y \\(\\sigma(B)\\) es el conjunto de autovalores de \\(B\\)."
  },
  {
    "objectID": "Gauss-seidel2.html#convergencia-de-los-métodos",
    "href": "Gauss-seidel2.html#convergencia-de-los-métodos",
    "title": "Jacobi y Gauss-Seidel",
    "section": "Convergencia de los métodos",
    "text": "Convergencia de los métodos\nMostrar que que un método converge no es simple, pero podemos establecer algunos criterios para determinar si un método converge o no.\n\nLo métodos iterativos de Jacobi y Gauss-Seidel convergen si la matriz \\(A\\) es diagonal dominante, es decir que el valor absoluto de la diagonal debe ser mayor que la suma de los valores absolutos de los elementos de la fila. \\[|a_{ii}| > \\sum_{j=1, j \\neq i}^{n} |a_{ij}|\\]\nSi la matriz \\(A\\) es simétrica y definida positiva, entonces el método de Gauss-Seidel converge.\n\nNote un sistema puede converger usando Jacobi o Gauss-Seidel pero podría no satisfacer alguno de estos criterios.\nEjercicio\nSea el siguiente sistema\n\\[\\begin{bmatrix} 8 & 2 & 1 \\\\ 5 & 4 & 1 \\\\ 4 & 3 & 4 \\end{bmatrix} \\begin{bmatrix} x_1 \\\\ x_2 \\\\ x_3 \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ 5 \\\\ 3 \\end{bmatrix}\\] + Muestre que la matriz \\(A\\) no es diagonal dominante. + Muestre que la matriz \\(A\\) no es simétrica y definida positiva.\n\nEncuentre la matriz \\(B\\) para el método de Jacobi y Gauss-Seidel, y encuentre el radio espectral de \\(B\\), para cada caso.\n¿El método de Jacobi converge? ¿El método de Gauss-Seidel converge?\n\nEjercicio\nSea el siguiente sistema\n\\[Ax=b\\]\ndonde\n\\[A=\\begin{bmatrix} 5&1&1&0&0&0&0&0\\\\1&5&1&1&0&0&0&0\\\\1&1&5&1&1&0&0&0\\\\0&1&1&5&1&1&0&0\\\\\n0&0&1&1&5&1&1&0\\\\0&0&0&1&1&5&1&1\\\\\n0&0&0&0&1&1&5&1\\\\\n0&0&0&0&0&1&1&5\\\\ \\end{bmatrix}\\]"
  },
  {
    "objectID": "proyecto2.html",
    "href": "proyecto2.html",
    "title": "Proyecto 2",
    "section": "",
    "text": "Los sistemas idealizados de masa resorte tiene aplicaciones numerosas en Ingeniería. en la siguiente figura se muestra un arreglo de 4 resortes en serie comprimidos por una fuerza de 2 000 kg. En el equilibrio, es posible desarrollar ecuaciones de balance de fuerzas si se definen las relaciones entre los resortes\n\n\n\n\nProceso de extracción\n\n\n\\[k_2(x_2-x_1)=k_1x_1\\] \\[k_3(x_3-x_2)=k_2(x_2-x_1)\\] \\[k_4(x_4-x_3)=k_3(x_3-x_2)\\] \\[F=k_4(x_4- x_3)\\]\ndonde las \\(k\\) son constantes de los resortes,\\(k_1=150\\),\\(k_2=50\\),\\(k_3=75\\) y \\(k_2=225\\) \\(N/m\\)\n\nDetermine las elongaciones de los resortes \\(x_1\\), \\(x_2\\), \\(x_3\\) y \\(x_4\\).\nEstudie el tiempo de computación para cada método.\nEncuentre el error del residuo para cada método.\n¿Qué método usted recomendaría?\n\nSuponga que se tiene un sistema de 20 resortes en serie, de forma similar al ejercicio anterior\n\nDescriba un sistema de ecuaciones que describa el sistema de resortes, suponiendo que se simulan linealizados, es decir, que la fuerza de cada resorte es proporcional a su elongación.\nSuponiendo que \\(k_i=100+i\\) \\(N/m\\) para \\(i=1,2,...,20\\) y \\(F=1000\\) \\(N\\), determine las elongaciones de los resortes \\(x_1\\), \\(x_2\\), \\(x_3\\) y \\(x_4\\).\nEstudie el tiempo de computación para cada método.\nEncuentre el error del residuo para cada método.\n¿Qué método usted recomendaría?\n\n\nEn muchas aplicaciones de ingeniería se debe calcular la inversa de una matriz.\n\n\nEscriba una algoritmo para calcular la inversa de una matriz cuadrada de \\(n\\times n\\). Usando soluciones de sistemas de ecuaciones lineales (use el que usted considere más adecuado)\nEstudie el tiempo de computación para cada método.\nVerifique que \\(A*A^{-1}=I\\), donde \\(A^{-1}\\), es la matriz que usted encontró.\nEl resultado fue el esperado, analice la situación.\n\n\nProceso de extracción en etapas En un sistema de proceso de extracción por etapas uan corriente que contiene una fracción de peso \\(Y_{ent}\\) de un producto químico ingresa por la izquierda con una tasa de flujo de masa \\(F_1\\). En forma simultanea un solvente que lleva una fracción de peso \\(X_{ent}\\) del mismo producto químico entra por la derecha con una tasa de flujo \\(F_2\\). Así por la etapa \\(i\\), en el balance de la masa se representa como\n\n\\[F_1Y_{i-1}+F_2X_{i+1}=F_1Y_i+F_2X_i,\\]\nen cada etapa, se supone que se establece el equilibrio entre \\(Y_i\\) y \\(X_i\\) como en\n\\[K=\\frac{X_i}{Y_i}\\]\ndonde \\(K\\) se denomina coeficiente de distribución. El proceso de extracción se puede representar como en la figura\n\n\n\nProceso de extracción\n\n\nen la ecuación anterior se puede despejar \\(X_i\\) y sustituir para obtener\n\\[Y_{i-1}-\\Big(1+\\frac{F_2}{F_1}K\\Big)Y_{i}+\\Big(\\frac{F_2}{F_1}K\\Big)Y_{i+1}=0\\]\nSi \\(F_1=400\\) \\(kg/h\\), \\(Y_{ent}=0.1\\), \\(F_2=800\\) \\(kg/h\\), \\(X_{ent}=0\\) y \\(K= 5\\), determine la composición de la corriente de salida \\(Y_{sal}\\) y \\(X_{sal}\\), si emplea un reactor de 5 etapas, de 10 etapas y de 20 etapas. Observe que la ecuación anterior deb modificarse para tomar en cuenta las fracciones de peso del flujo de entrada cuando se aplique a la primera y última ecuación.\n\nEncuentre la solución para 5, 10 y 20 etapas usando factorización LU, Gauss-Seidel y Jacobi, (use una tolerancia de \\(10^{-6}\\)).\nEstudie el tiempo de computación para cada método.\nEncuentre el error del residuo para cada método.\n¿Qué método usted recomendaría? Sacado de Metods numericos para ingenería de Steven C. Chapra"
  },
  {
    "objectID": "taller_parcial2.html",
    "href": "taller_parcial2.html",
    "title": "clases",
    "section": "",
    "text": "Taller de repaso parcial\n\nEscriba un pseudocódigo usando LU con pivotiamiento para encontrar la inversa de un matriz \\(A\\), suponiendo que la matriz es invertible.\nRealice una tabla comparativa para los siguientes métodos escribiendo, ventajas, desventajas, cuando se debe usar, cuando se debe evitar cuando es su convergencia. LU con y sin pivotiamiento, Cholescky, Jacobi y Gauss-seidell\nExplique que es numero de condición y por que es importante.\nResuelva el siguiente sistema de ecuaciones, \\[\\begin{bmatrix} 10^{-20} & 1  \\\\ 1 & 2  \\end{bmatrix} \\begin{bmatrix} x_1 \\\\ x_2  \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ 4  \\end{bmatrix}\\]\n\nUsando factorización LU con y sin pivoteo. Recuerde que computacionalmente \\(1+10^{-20} = 1\\) y \\(2-10^{20} = -10^{20}\\).\n\nAnalice el residuo generado por el sistema de ecuaciones anterior. ¿Es grande o pequeño? ¿Es un buen indicador de la solución? Encuentre la solución exacta el error absoluto. Realice este procesos usando las normas 1, 2 y \\(\\infty\\).\nPorque es importante usar pivoteo en la factorización LU para resolver sistemas de ecuaciones. De ejemplos.\nLas corrientes \\(i_1,i_2,i_3,i_4\\) y \\(i_5\\) en el circuito puede ser determinado\ndesde la solución del sistema de ecuaciones (obtenido aplicando la ley de Kirchhoff)\n\n\\[\\begin{equation}\n\\begin{split}\n9.5i_1-2.5i_2-2i_4=12,\\\\\n-2.5i_1+11i_2-3.5i_3-5i_5=-16,\\\\\n-3.5i_2+15.5i_3-4i_5=14,\\\\\n-2i_1+7i_4-3i_5=10,\\\\\n-5i_2-4i_3-3i_4+12i_5=-30.\n\\end{split}\n\\end{equation}\\]\n\n\n\nCircuito\n\n\nque método es el mas adecuado para resolver este sistema de ecuaciones?. Justifique su respuesta.\n\nComente cada línea del siguiente código que corresponde a algún método de solución de sistemas de ecuaciones. ¿A qué método corresponde?\n\n\nimport numpy as np\n\ndef metodo(A, b, x0, tol=1e-6, max_iter=100):\n    n = len(A)\n    x = x0.copy()\n    for iter_count in range(max_iter):\n        x_new = np.zeros(n)\n        for i in range(n):\n            s = np.dot(A[i, :i], x[:i]) + np.dot(A[i, i+1:], x[i+1:])\n            x_new[i] = (b[i] - s) / A[i, i]\n        if np.linalg.norm(x_new - x) < tol:\n            return x_new\n        x = x_new\n    raise Exception(\"El método  no converge después de {} iteraciones\".format(max_iter))\n\n\nSea el siguiente sistema de ecuaciones lineales \\[\\begin{bmatrix}\n2 & 1 & 0 &\\cdots &0&0&0\\\\\n1 & 2 & 0 &\\cdots &0&0&0 \\\\\n0 & 1 & 2 &\\cdots &0&0&0\\\\\n\\vdots & \\vdots & \\vdots &\\ddots &\\vdots&\\vdots &\\ddots &\\vdots\\\\\n0 & 0 & 0 &\\cdots &2&1&0\\\\\n0 & 0 & 0 &\\cdots &1&2&1\\\\\n0 & 0 & 0 &\\cdots &0&1&2\\\\\n\\end{bmatrix}\\begin{bmatrix} x_1 \\\\ x_2 \\\\ x_3\\\\ \\vdots\\\\x_{n-2}\\\\x_{n-1}\\\\ x_n\\end{bmatrix}=\\begin{bmatrix} b_1 \\\\ b_2 \\\\ b_3\\\\ \\vdots\\\\ b_{n-2}\\\\b_{n-1}\\\\ b_n\\end{bmatrix}\\]\n\n¿Cuales métodos se podrian usar para resolver este sistema de ecuaciones y por que?. ¿Qué método es el mas adecuado para resolver este sistema de ecuaciones? ¿Justifique su respuesta?\n\nSea la siguiente matriz\n\n\\[\\begin{bmatrix}1&2&3\\\\4&5&6\\\\7&8&9\\end{bmatrix}\\]\n\nEncuentre las normas 1, 2 y \\(\\infty\\) de la matriz.\n\n\nEncuentre el polinomio interpolante de Lagrange para los siguientes puntos\n\n\\[(-1,1),\\quad (0,0),\\quad (1,1),\\quad (2,0),\\quad (3,1)\\]\n\nA=np.loadtxt(\"matrix2.txt\")\nA\n\narray([[1.        , 0.5       , 0.33333333, 0.25      , 0.2       ,\n        0.16666667, 0.14285714, 0.125     , 0.11111111, 0.1       ,\n        0.09090909, 0.08333333, 0.07692308, 0.07142857, 0.06666667],\n       [0.5       , 0.33333333, 0.25      , 0.2       , 0.16666667,\n        0.14285714, 0.125     , 0.11111111, 0.1       , 0.09090909,\n        0.08333333, 0.07692308, 0.07142857, 0.06666667, 0.0625    ],\n       [0.33333333, 0.25      , 0.2       , 0.16666667, 0.14285714,\n        0.125     , 0.11111111, 0.1       , 0.09090909, 0.08333333,\n        0.07692308, 0.07142857, 0.06666667, 0.0625    , 0.05882353],\n       [0.25      , 0.2       , 0.16666667, 0.14285714, 0.125     ,\n        0.11111111, 0.1       , 0.09090909, 0.08333333, 0.07692308,\n        0.07142857, 0.06666667, 0.0625    , 0.05882353, 0.05555556],\n       [0.2       , 0.16666667, 0.14285714, 0.125     , 0.11111111,\n        0.1       , 0.09090909, 0.08333333, 0.07692308, 0.07142857,\n        0.06666667, 0.0625    , 0.05882353, 0.05555556, 0.05263158],\n       [0.16666667, 0.14285714, 0.125     , 0.11111111, 0.1       ,\n        0.09090909, 0.08333333, 0.07692308, 0.07142857, 0.06666667,\n        0.0625    , 0.05882353, 0.05555556, 0.05263158, 0.05      ],\n       [0.14285714, 0.125     , 0.11111111, 0.1       , 0.09090909,\n        0.08333333, 0.07692308, 0.07142857, 0.06666667, 0.0625    ,\n        0.05882353, 0.05555556, 0.05263158, 0.05      , 0.04761905],\n       [0.125     , 0.11111111, 0.1       , 0.09090909, 0.08333333,\n        0.07692308, 0.07142857, 0.06666667, 0.0625    , 0.05882353,\n        0.05555556, 0.05263158, 0.05      , 0.04761905, 0.04545455],\n       [0.11111111, 0.1       , 0.09090909, 0.08333333, 0.07692308,\n        0.07142857, 0.06666667, 0.0625    , 0.05882353, 0.05555556,\n        0.05263158, 0.05      , 0.04761905, 0.04545455, 0.04347826],\n       [0.1       , 0.09090909, 0.08333333, 0.07692308, 0.07142857,\n        0.06666667, 0.0625    , 0.05882353, 0.05555556, 0.05263158,\n        0.05      , 0.04761905, 0.04545455, 0.04347826, 0.04166667],\n       [0.09090909, 0.08333333, 0.07692308, 0.07142857, 0.06666667,\n        0.0625    , 0.05882353, 0.05555556, 0.05263158, 0.05      ,\n        0.04761905, 0.04545455, 0.04347826, 0.04166667, 0.04      ],\n       [0.08333333, 0.07692308, 0.07142857, 0.06666667, 0.0625    ,\n        0.05882353, 0.05555556, 0.05263158, 0.05      , 0.04761905,\n        0.04545455, 0.04347826, 0.04166667, 0.04      , 0.03846154],\n       [0.07692308, 0.07142857, 0.06666667, 0.0625    , 0.05882353,\n        0.05555556, 0.05263158, 0.05      , 0.04761905, 0.04545455,\n        0.04347826, 0.04166667, 0.04      , 0.03846154, 0.03703704],\n       [0.07142857, 0.06666667, 0.0625    , 0.05882353, 0.05555556,\n        0.05263158, 0.05      , 0.04761905, 0.04545455, 0.04347826,\n        0.04166667, 0.04      , 0.03846154, 0.03703704, 0.03571429],\n       [0.06666667, 0.0625    , 0.05882353, 0.05555556, 0.05263158,\n        0.05      , 0.04761905, 0.04545455, 0.04347826, 0.04166667,\n        0.04      , 0.03846154, 0.03703704, 0.03571429, 0.03448276]])\n\n\nA"
  },
  {
    "objectID": "clase.html",
    "href": "clase.html",
    "title": "clases",
    "section": "",
    "text": "import numpy as np\n\nx=np.linspace(0,1,10)\nx.reshape(-1, 1)\nA=np.zeros((11,11))\n\nx\n\narray([0.        , 0.11111111, 0.22222222, 0.33333333, 0.44444444,\n       0.55555556, 0.66666667, 0.77777778, 0.88888889, 1.        ])"
  },
  {
    "objectID": "taller_3.html",
    "href": "taller_3.html",
    "title": "clases",
    "section": "",
    "text": "Taller 3\nFecha de entrega máxima Noviembre 7\nEn el archivo taller_3.csv encontrará los datos reales del lanzamiento del Falcon Heavy. En este archivo se encuentran los datos, tiempo, velocidad, altitud, velocidad en x, velocidad en y, aceleración, distancia del rango inferior y ángulo. Para ver el video del lanzamiento . Para la siguiente actividad lea los datos del archivo taller_3.csv, usando la librería pandas y cree un DataFrame.\n\nHaga una gráfica de cada una de las variables en función del tiempo.\nFormule un estrategia e implemente, usando los algoritmos vistos en clase, para crear una función que ajuste la gráfica de la velocidad en función del tiempo de tal forma que el error de ajuste sea mínimo. \\[||\\vec{y}_i-\\vec{y}_{ajuste}(t_i)||_2\\]\nUsando un método de integración numérica calcule el desplazamiento recorrida en el eje x.\nDiseñe e implemente (usando sus conocimientos en ingeniería y física) un método para responder que la gráfica de velocidad y de aceleración corresponden al mismo objeto.\nEncuentre la velocidad angular y aceleración angular ¿Existe alguna relación lineal entre la velocidad angular y la aceleración angular? Justifique su respuesta.\nEncuentre una función continua para determinar la fuerza de gravedad de sobre el cohete en función del tiempo."
  },
  {
    "objectID": "diferencia.html",
    "href": "diferencia.html",
    "title": "clases",
    "section": "",
    "text": "Diferencias divididas de newton\nUna forma más eficiente de calcular el polinomio interpolante de Newton es mediante las diferencias divididas de Newton. El cual consiste en calcular los coeficientes de la siguiente forma: \\[f[x_0] = f(x_0)\\] \\[f[x_0,x_1] = \\frac{f(x_1)-f(x_0)}{x_1-x_0}\\] \\[f[x_0,x_1,x_2] = \\frac{f[x_1,x_2]-f[x_0,x_1]}{x_2-x_0}\\] \\[f[x_0,x_1,x_2,x_3] = \\frac{f[x_1,x_2,x_3]-f[x_0,x_1,x_2]}{x_3-x_0}\\] de forma general: \\[f[x_0,x_1,...,x_n] = \\frac{f[x_1,x_2,...,x_n]-f[x_0,x_1,...,x_{n-1}]}{x_n-x_0}\\]\n\n\n\n\n\n\n\n\n\n\n\\(x_i\\)\n\\(f(x_i)\\)\n\\(f[x_i,x_{+1}]\\)\n\\(f[x_i,x_{i+1},x_{i+2}]\\)\n\\(f[x_i,x_{i+1},x_{i+2}]\\)\n\n\n\n\n1\n0\n2\n1\n0\n\n\n2\n2\n5\n1\n————–\n\n\n4\n12\n8\n————–\n————–\n\n\n5\n20\n————–\n————–\n————–\n\n\n\nAsí el polinomio interpolante de Newton se puede escribir como: \\[P_n(x) = f[x_0] + f[x_0,x_1](x-x_0) + f[x_0,x_1,x_2](x-x_0)(x-x_1) + ... + f[x_0,x_1,...,x_n](x-x_0)(x-x_1)...(x-x_{n-1})\\]\nVeamos un ejemplo:\nSea la siguiente tabla de valores:\nSea la siguiente tabla de valores:\n\n\n\n\n\n\n\n\n\n\nx\n\\(f(x_i)\\)\n\\(f[x_i,x_i+1]\\)\n\\(f[x_i,x_i+1,x_i+2]\\)\n\\(f[x_i,x_i+1,x_i+2,x_i+3]\\)\n\n\n\n\n1\n0\n2\n1\n0\n\n\n2\n2\n5\n1\n\n\n\n4\n12\n8\n\n\n\n\n5\n20\n\n\n\n\n\n\nAsí el polinomio interpolante de Newton es: \\[c_0=f(x_0)=0\\] \\[c_1=f[x_0,x_1]=2\\] \\[c_2=f[x_0,x_1,x_2]=1\\] \\[c_3=f[x_0,x_1,x_2,x_3]=0\\]\nDe esta forma el polinomio interpolante de Newton es:\n\\[p(x)=0+2(x-1)+1(x-1)(x-2)+0(x-1)(x-2)(x-4)\\]\n\ndef calcular_diferencias_divididas(x, y):\n    n = len(x)\n    diferencias = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n        diferencias[i][0] = y[i]\n\n    for j in range(1, n):\n        for i in range(n - j):\n            diferencias[i][j] = (diferencias[i + 1][j - 1] - diferencias[i][j - 1]) / (x[i + j] - x[i])\n\n    return diferencias[0]\n\ndef evaluar_polynomial_newton(coeficientes, x, xi):\n    n = len(coeficientes)\n    resultado = coeficientes[0]\n    factor = 1\n\n    for i in range(1, n):\n        factor *= (xi - x[i - 1])\n        resultado += coeficientes[i] * factor\n\n    return resultado\n\n# Datos de ejemplo\nx = [1, 2, 4,5]\ny = [0, 2, 12, 20]\n\n# Calcular las diferencias divididas\ncoeficientes = calcular_diferencias_divididas(x, y)\n\n# Evaluar el polinomio de Newton en un valor específico, por ejemplo, x = 1.5\nxi = 1.5\nresultado = evaluar_polynomial_newton(coeficientes, x, xi)\nprint(f\"El valor interpolado en x = {xi} es: {resultado}\")\ncoeficientes\n\nEl valor interpolado en x = 1.5 es: 0.75\n\n\n[0, 2.0, 1.0, 0.0]\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nf =lambda x:1/(1+x**2)\nx = np.linspace(-5,5,11) \ny = f(x)\nxi=np.linspace(-5,5,100)\n\n##\ncoeficientes = calcular_diferencias_divididas(x, y)\nresultado = evaluar_polynomial_newton(coeficientes, x, xi)\n\n\nyi=f(xi)\nplt.plot(x,y,'o',xi,resultado,'-',xi,yi,'--')"
  },
  {
    "objectID": "splines.html",
    "href": "splines.html",
    "title": "clases",
    "section": "",
    "text": "Los splines son otra herramienta para hacer interpolación de datos. La idea es que en lugar de usar polinomios de grado fijo, se usan polinomios de grado variable, que se van ajustando a los datos. En particular, los splines cúbicos son muy populares.\nLa idea es la siguiente: se tienen \\(n\\) puntos \\((x_i, y_i)\\), y se quiere encontrar una función \\(S(x)\\) lineal que pase por todos los puntos. Para ello, se divide el intervalo \\([x_0, x_n]\\) en \\(n\\) subintervalos \\([x_i, x_{i+1}]\\), y se define un polinomio \\(S_i(x)\\) en cada subintervalo, de tal manera que \\(S(x)\\) sea una función continua, y que \\(S(x_i) = y_i\\).\n\n## Ejemplo de splines lineales y cuadráticos\nimport numpy as np\nimport matplotlib.pyplot as plt\nf = lambda x: np.sin(x) + np.sin(10*x)\nx = np.linspace(0, 2*np.pi, 10)\nx1 = np.linspace(0, 2*np.pi, 100)\ny = f(x)\ny1 = f(x1)\nplt.plot(x, y, 'k', label='splines')\nplt.plot(x1, y1, 'red', label='f(x)')\nplt.plot(x, y, 'k.')\n\n\n\n\n\nCuales son las propiedades de los splines lineales\n\nEs una función continua\nNo es diferenciable\nEs una función lineal a trozos\nRelativamente fácil de calcular\n\n\n\n\nEncuentre un algoritmo para encontrar los coeficientes de los splines lineales, y prográmelo.\n\n\n\nDe los datos del la gráfica anterior, encuentre el valor de \\(y\\) para \\(x=1.5\\) usando splines lineales.\n\n\ndef gauss_seidel(A, b, x0, tol=1e-6, max_iter=1000):\n    \"\"\"\n    Solves the linear system Ax = b using the Gauss-Seidel method.\n    Returns the solution x and the number of iterations used.\n    \"\"\"\n    n = len(b)\n    x = np.copy(x0)\n    iter = 0\n    \n    while iter < max_iter:\n        iter += 1\n        for i in range(n):\n            suma = 0\n            for j in range(n):\n                if j != i:\n                    suma += A[i][j] * x[j]\n            x[i] = (b[i] - suma) / A[i][i]\n        if np.linalg.norm(x - x0) < tol:\n            return x, iter\n        x0 = np.copy(x)\n    \n    raise ValueError(\"Gauss-Seidel failed to converge after {} iterations\".format(max_iter))"
  },
  {
    "objectID": "splines.html#ejercicio",
    "href": "splines.html#ejercicio",
    "title": "clases",
    "section": "Ejercicio",
    "text": "Ejercicio\nEncuentre un algoritmo para encontrar los coeficientes de los splines lineales, y prográmelo."
  },
  {
    "objectID": "splines.html#ejercicio-1",
    "href": "splines.html#ejercicio-1",
    "title": "clases",
    "section": "Ejercicio",
    "text": "Ejercicio\nDe los datos del la gráfica anterior, encuentre el valor de \\(y\\) para \\(x=1.5\\) usando splines lineales.\n\n\ndef gauss_seidel(A, b, x0, tol=1e-6, max_iter=1000):\n    \"\"\"\n    Solves the linear system Ax = b using the Gauss-Seidel method.\n    Returns the solution x and the number of iterations used.\n    \"\"\"\n    n = len(b)\n    x = np.copy(x0)\n    iter = 0\n    \n    while iter < max_iter:\n        iter += 1\n        for i in range(n):\n            suma = 0\n            for j in range(n):\n                if j != i:\n                    suma += A[i][j] * x[j]\n            x[i] = (b[i] - suma) / A[i][i]\n        if np.linalg.norm(x - x0) < tol:\n            return x, iter\n        x0 = np.copy(x)\n    \n    raise ValueError(\"Gauss-Seidel failed to converge after {} iterations\".format(max_iter))"
  },
  {
    "objectID": "taller_inter.html",
    "href": "taller_inter.html",
    "title": "clases",
    "section": "",
    "text": "Taller interpolación\n\nPrograme el algoritmo para encontrar los polinomios interpolador para n puntos usando diferencias divididas de Newton\n\n\nSea los siguientes puntos\n\n\n\n\n\\(x_i\\)\n0.10000\n0.30000&\n0.50000\n\n\n\n\n\\(y_i\\)\n-1.377000\n0.061000\n1.875000\n\n\n\n\nEncuentre el polinomio que interpola estos puntos usando un sistema de ecuaciones\nEncuentre el polinomio interpolador usando polinomios de Lagrange\nEncuentre la solución usando diferencias divididas de Newton\n\n\nSea los siguientes puntos\n\n\n\n\n\\(x_i\\)\n0.10000\n0.30000\n0.50000\n0.70000\n\n\n\n\n\\(y_i\\)\n-1.380000\n-0.020000\n1.500000\n3.180000\n\n\n\n\nEncuentre la solución usando diferencias divididas de Newton\n¿Por qué en este caso \\(a_3=0\\)? Justifique su respuesta\n\n\nSea los siguientes puntos\n\n\n\n\n\\(x_i\\)\n0.01\n-0.01\n0.1\n-0.1\n1\n-1\n\n\n\n\n\\(y_i\\)\n-0.50637\n0.50637\n-0.54402\n0.54402\n0.84147\n-0.84147\n\n\n\n\nEncuentre el polinomio que interpola estos puntos usando un sistema de ecuaciones generado por una matriz\nEncuentre la solución usando diferencias divididas de Newton\nGrafique el polinomio obtenido en cada uno de los puntos anteriores\nCompare esa gráfica con \\(f(x)=1/\\sin(x)\\)\n\n\nSea \\(f(x)=\\sin(x)\\), si queremos interpolar esta función en el intervalo \\([0,\\pi]\\) para los puntos \\(x_i=0, \\frac{1}{4}\\pi, \\frac{1}{2}\\pi,\\frac{3}{4}\\pi\\) y \\(\\pi\\). Encuentre el error del polinomio en ese intervalo. ¿Considera que ese polinomio es una buena aproximación de la función \\(f(x)\\)?. Justifique su respuesta.\nDescriba que el fenómeno Runge. De un ejemplo del método Runge.\nConsulte el siguiente comando la librería. Úselo para interpolar el punto 4 y compare sus respuestas. ¿Cómo obtendría el valor de \\(f(0.2)\\)?\nObserve los siguientes puntos\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nplt.style.use('seaborn-poster')\n\n# generate x and y\nx = np.linspace(0, 1, 101)\ny = 1 + x + x * np.random.random(len(x))\n\n# plot the results\nplt.figure(figsize = (10,8))\nplt.plot(x, y, 'b.')\n\nplt.xlabel('x')\nplt.ylabel('y')\nplt.show()\n\n\n\n\nNote que es tienen un comportamiento lineal, Encuentre una recta que minimice el error cuadrático de los puntos dados. Para ello el método de cuadrados mínimos. Encuentre la magnitud del error.\n\\[||y-\\hat{y}||_2\\] donde \\(y\\) es el vector de los puntos dados y \\(\\hat{y}\\) es el vector de los puntos estimados.\n\nObserve los siguientes puntos\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nplt.style.use('seaborn-poster')\n\n# let's generate x and y, and add some noise into y\nx = np.linspace(0, 10, 101)\ny = 0.1*np.exp(0.3*x) + 0.1*np.random.random(len(x))\n\n# Let's have a look of the data\nplt.figure(figsize = (10,8))\nplt.plot(x, y, 'b.')\nplt.xlabel('x')\nplt.ylabel('y')\nplt.show()\n\n\n\n\nNote que tiene un comportamiento de la forma\n\\[y=ae^{bx}\\]\neste sistema lo podemos linealizar tomando logaritmos\n\\[\\ln(y)=\\ln(a)+bx\\]\nEncuentre una recta que minimice el error cuadrático de los puntos dados. Para ello el método de cuadrados mínimos y grafique su respuesta en el mismo gráfico de los puntos dados. Encuentre la magnitud del error.\n\\[||y-\\hat{y}||_2\\] donde \\(y\\) es el vector de los puntos dados y \\(\\hat{y}\\) es el vector de los puntos estimados.\n\nEjemplo con datos reales.\n\nVamos a usar los datos de pingüinos, los cuales se encuentran pre-cargados en la librería searbosn y que nos permiten analizar la relación entre la longitud del pico y la masa corporal de los pingüinos. En la librearía seaborn podemos encontrar información de tres tipos de especies y en donde podemos analizar las siguientes variables: * bill_length_mm: longitud del pico en milímetros * bill_depth_mm: profunidad del pico en milímetros * flipper_length_mm: longitud de las alas en milímetros * body_mass_g: masa corporal en gramos * species: especie de pingüino\n\nimport numpy as np\nfrom scipy.stats import norm \nimport pandas as pd \nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n%matplotlib inline\nplt.rcParams['figure.figsize'] = (20, 10)\nplt.style.use('ggplot')\n\nimport warnings\nwarnings.filterwarnings('ignore')\n\n\ndf = sns.load_dataset(\"penguins\")\ntype(df) # note que df es un objeto de tipo DataFrame  de pandas\n# para visualizar el encabezado del DataFrame\ndf.head()\n\n\n\n\n\n  \n    \n      \n      species\n      island\n      bill_length_mm\n      bill_depth_mm\n      flipper_length_mm\n      body_mass_g\n      sex\n    \n  \n  \n    \n      0\n      Adelie\n      Torgersen\n      39.1\n      18.7\n      181.0\n      3750.0\n      Male\n    \n    \n      1\n      Adelie\n      Torgersen\n      39.5\n      17.4\n      186.0\n      3800.0\n      Female\n    \n    \n      2\n      Adelie\n      Torgersen\n      40.3\n      18.0\n      195.0\n      3250.0\n      Female\n    \n    \n      3\n      Adelie\n      Torgersen\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n    \n    \n      4\n      Adelie\n      Torgersen\n      36.7\n      19.3\n      193.0\n      3450.0\n      Female\n    \n  \n\n\n\n\n\n# para visualizar el tamaño del DataFrame\nprint('Total de elementos ',df.size)\n\n# para visualizar el número de filas y columnas del DataFrame\nprint('Número de filas y columnas',df.shape)\n\nTotal de elementos  2408\nNúmero de filas y columnas (344, 7)\n\n\n\n\npara visualizar los datos estadísticos básicos del DataFrame\ndf.describe()\n\n# aqui primero debemos mirar si hay datos faltantes\nprint(df.isnull()) # esto nos devuelve un DataFrame de booleanos\n# aqui imprime si el dato es  faltante o no\nprint(df.isnull().sum()) # esto nos devuelve la suma de los valores faltantes por columna\n\n     species  island  bill_length_mm  bill_depth_mm  flipper_length_mm  \\\n0      False   False           False          False              False   \n1      False   False           False          False              False   \n2      False   False           False          False              False   \n3      False   False            True           True               True   \n4      False   False           False          False              False   \n..       ...     ...             ...            ...                ...   \n339    False   False            True           True               True   \n340    False   False           False          False              False   \n341    False   False           False          False              False   \n342    False   False           False          False              False   \n343    False   False           False          False              False   \n\n     body_mass_g    sex  \n0          False  False  \n1          False  False  \n2          False  False  \n3           True   True  \n4          False  False  \n..           ...    ...  \n339         True   True  \n340        False  False  \n341        False  False  \n342        False  False  \n343        False  False  \n\n[344 rows x 7 columns]\nspecies               0\nisland                0\nbill_length_mm        2\nbill_depth_mm         2\nflipper_length_mm     2\nbody_mass_g           2\nsex                  11\ndtype: int64\n\n\n\n# para manipular la  base de datos debemos hacer una copia\n\ndf1 = df.copy()\n\n\n#vamos a buscar los datos faltantes en la columna \"body_mass_g\"\nprint(df1['body_mass_g'].isnull().sum()) # esto nos devuelve la suma de los valores faltantes por columna\n\n2\n\n\n\n#vamos a ver la fila de los datos faltantes en la columna \"body_mass_g\"\nprint(df1[df1['body_mass_g'].isnull()])\n\n    species     island  bill_length_mm  bill_depth_mm  flipper_length_mm  \\\n3    Adelie  Torgersen             NaN            NaN                NaN   \n339  Gentoo     Biscoe             NaN            NaN                NaN   \n\n     body_mass_g  sex  \n3            NaN  NaN  \n339          NaN  NaN  \n\n\nNecesitamos buscar alguna estrategia para estudiar los datos, por ejemplo, podemos rellenarlos con el promedio, o podemos omitir esos datos, o podemos usar la regresión lineal para estimar los valores faltantes (Note que para buscar una estrategia siempre es dependiente al problema). Para este caso vamos a omitir los datos faltantes.\n\n# eliminar la fila con los datos faltantes\ndf1.dropna(subset=['body_mass_g'], inplace=True)\nprint(df1.isnull().sum()) # esto nos devuelve la suma de los valores faltantes por columna\nprint(df1.shape) # para visualizar el número de filas y columnas del DataFrame\n\nspecies              0\nisland               0\nbill_length_mm       0\nbill_depth_mm        0\nflipper_length_mm    0\nbody_mass_g          0\nsex                  9\ndtype: int64\n(342, 7)\n\n\nVamos a estudiar la relación entre la longitud del pico y la masa corporal de los pingüinos. Para ello vamos a ver si existe una relación lineal entre estas dos variables. Una forma básica de estudiar dicha relación es hacer un primer gráfico de dispersión de los datos.\n\nby=df1[\"body_mass_g\"] # extraemos la columna body_mass_g\nbl=df1[\"bill_length_mm\"] # extraemos la columna bill_length_mm\n\n\n\nplt.scatter(by, bl)\nplt.xlabel(\"body mass grams\")\nplt.ylabel(\"bill length mm\")\nplt.title(\"Relationship between body mass and bill length\")\nplt.show()\n\n\n\n\nEncuentre una recta que minimice el error cuadrático de los puntos dados. Para ello el método de cuadrados mínimos y grafique su respuesta en el mismo gráfico de los puntos dados. Encuentre la magnitud del error.\n\\[||y-\\hat{y}||_2\\] donde \\(y\\) es el vector de los puntos dados y \\(\\hat{y}\\) es el vector de los puntos estimados.\n\nEstudie la librería numpy para resolver el problema anterior. Compare sus resultados."
  },
  {
    "objectID": "splines.html#ejercicio-2",
    "href": "splines.html#ejercicio-2",
    "title": "clases",
    "section": "Ejercicio",
    "text": "Ejercicio\nEscriba un sistema de ecuaciones adecuado para resolver el problema, cuando se construye el sistema se busca que la matriz tenga propiedades intrínsecas (si es posible) como que la matriz sea simétrica"
  },
  {
    "objectID": "splines.html#ejercicio-3",
    "href": "splines.html#ejercicio-3",
    "title": "clases",
    "section": "Ejercicio",
    "text": "Ejercicio\nPlantee el sistema para cuatro puntos."
  },
  {
    "objectID": "integracion.html",
    "href": "integracion.html",
    "title": "clases",
    "section": "",
    "text": "La integración numerica es una herramienta muy importante en la computación cientifica, esta l podemos dividir en dos grandes grupos\n\nIntegración de Newton Cotes.\nIntegración de cuadraturas.\n\nEn la primera usamos la aproximación usando interpolación de polinomios, en la segunda usamos proyección de los polinomios. Vamos ver algunos ejemplos y algoritmos para cada uno de los casos.\n\n\nEn el pasado uno de los primeros métodos para aproximar el área de una curva se usaba el método de Exhausción, que posteriormente se transformo en las sumas de Riemman, este método consiste en aproximar el área de una curva usando rectángulos, como se muestra en la siguiente figura.\n\n\n\nsumas de Riemman\n\n\nEste tal vez fue el primer método numérico para aproximar integrales numéricas. En este punto nos surge diferentes preguntas, ¿qué tan buena son esas aproximaciones?, ¿se puede mejorar?, ¿cual es el error asociado a la aproximación? ¿Cómo lo cálculo?\nPara poder responder cada una de estas preguntas, vamos a aproximar la integrar en un simple intervalo \\([a,b]\\) usando diferentes aproximaciones,\n\n\n\nSuponemos que tenemos un función continua en un intervalo \\([a,b]\\), vamos a aproximar este función usando los polinomios de Lagrange, como se muestra en la figura\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define la función original que deseas interpolar\ndef original_function(x):\n    return x**5  # Ejemplo: Función seno\n\n# Puntos de interpolación\n\nx_points = np.array([0, 1])\ny_points = original_function(x_points)\n\n# Puntos en el dominio para trazar la función original\nx_values = np.linspace(0, x_points[-1], 100)\ny_values = original_function(x_values)\n\n# Polinomio de Lagrange\ndef lagrange_interpolation(x, x_points, y_points):\n    n = len(x_points)\n    result = 0\n    for j in range(n):\n        term = y_points[j]\n        for i in range(n):\n            if i != j:\n                term *= (x - x_points[i]) / (x_points[j] - x_points[i])\n        result += term\n    return result\n\n# Valores interpolados utilizando el polinomio de Lagrange\ny_interpolated = lagrange_interpolation(x_values, x_points, y_points)\n\n# Gráfica de la función original y la interpolación de Lagrange\nplt.figure(figsize=(8, 6))\nplt.plot(x_values, y_values, label=\"Función Original\", color='blue')\nplt.scatter(x_points, y_points, label=\"Puntos de Interpolación\", color='red')\nplt.plot(x_values, y_interpolated, label=\"Interpolación de Lagrange\", color='green')\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.legend()\nplt.title(\"Interpolación de un Polinomio de Lagrange\")\nplt.grid(True)\nplt.show()\n\n\n\n\nDe esta forma, podemos aproximar la función\n\\[f(x)\\approx\\frac{x-x_1}{x_0-x_1}+E(x),\\] donde \\(E(x)\\) representa el error asociado a la aproximación. De esta forma al integrar sobre el intervalo \\([x_0,x_1]\\) tenemos\n\\[\\begin{align}\\int_{x_0}^{x_1}f(x)\\ dx&\\approx\\int_{x_0}^{x_1}\\frac{x-x_0}{x_1-x_0}y_1+\\frac{x-x_1}{x_0-x_1}y_0dx+\\int_{x_0}^{x_1}E(x)dx\\\\\n&=\\frac{1}{x_1-x_0}\\Big(y_1\\int_{x_0}^{x_1}(x-x_0)dx-y_0\\int_{x_0}^{x_1}(x-x_0+x_0-x_1)dx\\Big)+\\int_{x_0}^{x_1}E(x)dx\\end{align},\\]\nhaciendo \\(u=x-x_0\\) in la primera integral, tenemos \\[\\begin{align}\\int_{x_0}^{x_1}f(x)\\ dx&=\\frac{1}{\\Delta x}\\Big(y_1\\int_{0}^{\\Delta x}(u)dx-y_0\\int_{0}^{\\Delta x}(u-\\Delta x)dx\\Big)+\\int_{x_0}^{x_1}E(x)dx\\\\\n&=\\frac{1}{\\Delta x}\\Big(\\frac{\\Delta^2 x}{2}y_1-\\Big(\\frac{\\Delta^2x}{2}+\\Delta^2 x\\Big)y_0\\Big)+\\int_{x_0}^{x_1}E(x)dx\\\\\n&=\\frac{\\Delta x}{2}\\Big(y_0+y_1\\Big)+\\int_{x_0}^{x_1}E(x)dx \\end{align},\\]\n\n\n\n\nimport numpy as np\n\ndef f(x):\n    # Define the function you want to integrate here\n    return x**5  # Example: x^2\n\ndef trapezoidal_rule_numpy(f, a, b, n):\n    h = (b - a) / n\n    x = np.linspace(a, b, n + 1)\n    y = f(x)\n\n    integral = h * (y[0] / 2 + np.sum(y[1:n]) + y[n] / 2)\n    return integral\n\na = 0  # Lower bound of integration\nb = 2  # Upper bound of integration\nn = 9  # Number of subintervals\n\nresult = trapezoidal_rule_numpy(f, a, b, n)\nprint(\"Approximate integral:\", result)\n\nApproximate integral: 10.995071889447743\n\n\nTrapecio, librería scipy\n\nfrom scipy import integrate\nimport numpy as np\nimport matplotlib.pyplot as plt\nx = np.linspace(-2, 2, num=20)\ny = x\nprint(integrate.trapezoid(y,x))\n\ny_int = integrate.cumulative_trapezoid(y, x, initial=0)\nplt.plot(x, y_int, 'ro', x, y[0] + 0.5 * x**2, 'b-')\nplt.show()\n\n-5.551115123125783e-17\n\n\n\n\n\nNote, toda función se puede aproximar\nla función\n\\[f(x)\\approx P_n+E(x)\\] donde el \\(P_n(x)\\) es el polinomio de Lagrange de grado \\(n\\) que interpola un conjunto de \\(n+1\\) puntos \\((x_0, y_0), (x_1, y_1), \\ldots, (x_n, y_n)\\) en el dominio \\(x\\) y codominio \\(y\\) está dado por: \\[ P_n(x) = \\sum_{k=0}^n y_k \\cdot L_k(x). \\] Con \\(L_k(x)\\) es el término de Lagrange correspondiente a \\(x_k\\), y se define como: \\[ L_k(x) = \\prod_{i=0, i\\neq k}^n \\frac{x - x_i}{x_k - x_i} \\]\nEl error de interpolación \\(E(x)\\) al utilizar un polinomio de Lagrange de grado \\(n\\) para aproximar una función \\(f(x)\\) en el punto \\(x\\) está dado por: \\[ E(x) = \\frac{f^{(n+1)}(c)}{(n+1)!} \\cdot \\omega(x) \\] Donde: - \\(f^{(n+1)}(c)\\) es la \\((n+1)\\)-ésima derivada de \\(f(x)\\) en algún punto \\(c\\) dentro del intervalo de interpolación. - \\(\\omega(x) = (x - x_0)(x - x_1) \\cdots (x - x_n)\\) se conoce como el “producto ponderado” y está relacionado con la diferencia finita.\nDe esta forma tenemos que\n\\[\\begin{align}\\int_{x_0}^{x_n}f(x)\\ dx&\\approx \\int_{x_0}^{x_n} P_n\\ dx+\\int_{x_0}^{x_n}E(x)\\ dx\\\\\n&\\approx \\int_{x_0}^{x_n}\\sum_{k=0}^n y_k \\cdot L_k(x)+\\int_{x_0}^{x_n}E(x)\\ dx\\\\\n&\\approx \\sum_{k=0}^ny_k\\int_{x_0}^{x_n} L_k(x)+\\int_{x_0}^{x_n}E(x)\\ dx\\end{align}\\]\nNote que\n\\[w_k=\\int_{x_0}^{x_n}  L_k(x)\\ dx\\]\nse puede calcular directamente, entonces:\n\\[\\int_{x_0}^{x_n}f(x)\\ dx\\approx \\sum_{k=0}^ny_kw_k\\]\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define la función original que deseas interpolar\ndef original_function(x):\n    return x**5  # Ejemplo: Función seno\n\n# Puntos de interpolación\n\nx_points = np.array([0, 0.5,1])\ny_points = original_function(x_points)\n\n# Puntos en el dominio para trazar la función original\nx_values = np.linspace(0, x_points[-1], 100)\ny_values = original_function(x_values)\n\n# Polinomio de Lagrange\ndef lagrange_interpolation(x, x_points, y_points):\n    n = len(x_points)\n    result = 0\n    for j in range(n):\n        term = y_points[j]\n        for i in range(n):\n            if i != j:\n                term *= (x - x_points[i]) / (x_points[j] - x_points[i])\n        result += term\n    return result\n\n# Valores interpolados utilizando el polinomio de Lagrange\ny_interpolated = lagrange_interpolation(x_values, x_points, y_points)\n\n# Gráfica de la función original y la interpolación de Lagrange\nplt.figure(figsize=(8, 6))\nplt.plot(x_values, y_values, label=\"Función Original\", color='blue')\nplt.scatter(x_points, y_points, label=\"Puntos de Interpolación\", color='red')\nplt.plot(x_values, y_interpolated, label=\"Interpolación de Lagrange\", color='green')\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.legend()\nplt.title(\"Interpolación de un Polinomio de Lagrange\")\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\nHaciendo la interpolación de un polinomio de segundo orden el intervalo \\([x_0,x_2]\\), usando el procedimiento anterior obtenemos la formula\n\\[\\int_{x_0}^{x_2}f(x)\\ dx\\approx \\frac{\\Delta x}{3}\\Big(f(x_0)+4f(x_1)+f(x_2)\\Big).\\] Con error\n\\[ E_f=-\\frac{\\Delta^5 x}{90}f^{(4)}(\\xi),\\]\nde esta forma \\[|E_f|\\leq \\frac{\\Delta^5 x}{90}max_{a\\leq\\xi\\leq b}|f^{(4)}(\\xi)|.\\]\n\n\n\nEn el caso de un intervalo \\([a,b]\\), haciendo una partición equidistante\n\\[\\int_a^bf(x)\\ dx\\approx\\frac{\\Delta x}{3}\\Big(f(x_0)+\\sum_{k=1}^{\\frac{n}{2}-1}f(x_{2k})+4\\sum_{k=1}^{\\frac{n}{2}}f(x_{2k-1})+f(x_n)\\Big)\\]\ncon error\n\\[(b-a)\\frac{\\Delta^4 x}{180}max_{a\\leq\\xi\\leq b}|f^{(4)}(\\xi)|.\\]\n\n\n\n\n\nimport numpy as np\n\ndef f(x):\n    # Define the function you want to integrate here\n    return x**5  # Example: x^2\n\ndef simpsons_rule_numpy(f, a, b, n):\n    if n % 2 != 0:\n        raise ValueError(\"Number of subintervals (n) must be even for Simpson's Rule.\")\n\n    h = (b - a) / n\n    x = np.linspace(a, b, n + 1)\n    y = f(x)\n\n    integral = h / 3 * (y[0] + 4 * np.sum(y[1:n:2]) + 2 * np.sum(y[2:n-1:2]) + y[-1])\n    return integral\n\na = 0  # Lower bound of integration\nb = 2  # Upper bound of integration\nn = 10  # Number of subintervals (should be even)\n\nresult = simpsons_rule_numpy(f, a, b, n)\nprint(\"Approximate integral:\", result)\n\nApproximate integral: 10.668800000000003\n\n\n\n\n\nHaciendo la interpolación de un polinomio de segundo orden el intervalo \\([x_0,x_3]\\), usando el procedimiento anterior obtenemos la formula\n\\[\\int_{x_0}^{x_3}f(x)\\ dx\\approx \\frac{3\\Delta x}{8}\\Big(f(x_0)+3f(x_1)+3f(x_2)+f(x_3)\\Big).\\] Con error\n\\[ E_f=-\\frac{3\\Delta^5 x}{80}f^{(4)}(\\xi),\\]\nde esta forma \\[|E_f|\\leq \\frac{3\\Delta^5 x}{80}max_{a\\leq\\xi\\leq b}|f^{(4)}(\\xi)|.\\]\n\n\nEn el caso de un intervalo \\([a,b]\\), haciendo una partición equidistante\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define la función original que deseas interpolar\ndef original_function(x):\n    return x**5  # Ejemplo: Función seno\n\n# Puntos de interpolación\n\nx_points = np.array([0, 0.25,0.5,0.75])\ny_points = original_function(x_points)\n\n# Puntos en el dominio para trazar la función original\nx_values = np.linspace(0, x_points[-1], 100)\ny_values = original_function(x_values)\n\n# Polinomio de Lagrange\ndef lagrange_interpolation(x, x_points, y_points):\n    n = len(x_points)\n    result = 0\n    for j in range(n):\n        term = y_points[j]\n        for i in range(n):\n            if i != j:\n                term *= (x - x_points[i]) / (x_points[j] - x_points[i])\n        result += term\n    return result\n\n# Valores interpolados utilizando el polinomio de Lagrange\ny_interpolated = lagrange_interpolation(x_values, x_points, y_points)\n\n# Gráfica de la función original y la interpolación de Lagrange\nplt.figure(figsize=(8, 6))\nplt.plot(x_values, y_values, label=\"Función Original\", color='blue')\nplt.scatter(x_points, y_points, label=\"Puntos de Interpolación\", color='red')\nplt.plot(x_values, y_interpolated, label=\"Interpolación de Lagrange\", color='green')\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.legend()\nplt.title(\"Interpolación de un Polinomio de Lagrange\")\nplt.grid(True)\nplt.show()\n\n\n\n\n\\[\\int_a^bf(x)\\ dx\\approx\\frac{3\\Delta x}{8}\\Big(f(x_0)+3\\sum_{k=0}^{\\frac{n}{3}-1}f(x_{3k+1})+3\\sum_{k=0}^{\\frac{n}{3}-1}f(x_{3k+2})+3\\sum_{k=0}^{\\frac{n}{3}-2}f(x_{3k+3})+f(x_n)\\Big)\\]\ncon error\n\\[|E_f|\\leq(b-a)\\frac{\\Delta^4 x}{80}max_{a\\leq\\xi\\leq b}|f^{(4)}(\\xi)|.\\]\n\nimport numpy as np\n\ndef f(x):\n    # Define la función que deseas integrar aquí\n    return x**5  # Ejemplo: x^2\n\ndef simpsons_3_8_rule_numpy(f, a, b, n):\n    if n % 3 != 0:\n        raise ValueError(\"El número de subintervalos (n) debe ser múltiplo de 3 para la regla de Simpson 3/8.\")\n\n    h = (b - a) / n\n    x = np.linspace(a, b, n + 1)\n    y = f(x)\n\n    integral = (3 * h / 8) * (y[0] + 3 * np.sum(y[1:n-2:3]) + 3 * np.sum(y[2:n-1:3]) + 2 * np.sum(y[3:n-3:3]) + y[n])\n    return integral\n\na = 0  # Límite inferior de integración\nb = 2  # Límite superior de integración\nn = 9  # Número de subintervalos (múltiplo de 3)\n\nresult = simpsons_3_8_rule_numpy(f, a, b, n)\nprint(\"Integral aproximada:\", result)\n\n\n\n\n\nUsando Scipy\n\n\n\nfrom scipy import integrate\nimport numpy as np\nx = np.arange(0, 10)\ny = np.arange(0, 10)\nintegrate.simpson(y, x)"
  },
  {
    "objectID": "taller_integracion.html",
    "href": "taller_integracion.html",
    "title": "clases",
    "section": "",
    "text": "Ejercicios\n\nEscriba un seudo-codigo dla regla del trapecio\nAproxime la integral \\(\\int_0^2x^2ln(x^2+1)\\,dx\\) usando \\(h=1/3\\) Use\n\nLa regla del trapecio\nLa regla de Simpsoms 1/3\nLa regla de Simpsoms 3/8\n\nDetermine el valor de \\(n\\) y de \\(h\\) que se requiere para aproximar\n\n\\(\\int_0^2 e^{2x}\\sin(3x)\\,dx\\), esperando que el error total sea menor que \\(10^{-4}\\), usando\nLa regla del trapecio\nLa regla de Simpsoms 1/3\nLa regla de Simpsoms 3/8\n\nAplicando la regla del trapecio para aproximar \\(\\int_0^2f(x)\\,dx\\) da un valor de 4, y la regla de Simpson de un 1/3 da un valor de 2. ¿Cual es el valor de f(1)?"
  },
  {
    "objectID": "diferential.html",
    "href": "diferential.html",
    "title": "Diferenciacion numérica",
    "section": "",
    "text": "La regla de Taylor es una aproximación de una función en un punto, mediante una serie de Taylor truncada. La serie de Taylor de una función \\(f(x)\\) alrededor de un punto \\(x_0\\) es:\n\\[f(x) = f(x_0) + \\frac{f'(x_0)}{1!}(x-x_0) + \\frac{f''(x_0)}{2!}(x-x_0)^2 + \\frac{f'''(x_0)}{3!}(x-x_0)^3 + \\cdots\\]\nnosotros podemos substituir \\(x\\) por \\(x_0+h\\) para obtener:\n\\[f(x_0+h) = f(x_0) + \\frac{f'(x_0)}{1!}h + \\frac{f''(x_0)}{2!}h^2 + \\frac{f'''(x_0)}{3!}h^3 + \\cdots\\]\nnote que esta serie la podemos truncar en el término que deseemos, por ejemplo, si truncamos en el término \\(h^2\\) obtenemos:\n\\[f(x_0+h) \\approx f(x_0) + \\frac{f'(x_0)}{1!}h + \\mathcal{O}(h^2),\\] y si despejamos \\(f'(x_0)\\) obtenemos:\n\\[f'(x_0) \\approx \\frac{f(x_0+h) - f(x_0)}{h}+ \\mathcal{O}(h).\\]\nNote que \\(\\mathcal{O}(h^2)/h= \\mathcal{O}(h)\\) y representa el error de truncamiento de la serie de Taylor y necesita evaluar al función en dos puntos \\(x_0+h\\) y \\(x_0\\). De esta forma, podemos decir que la aproxiamciópn de la derivada de la función \\(f(x)\\) en el punto \\(x_0\\) de orden 1 es: \\[f'(x_0) \\approx \\frac{f(x_0+h) - f(x_0)}{h}.\\]\nPodemos crear más aproximaciones de la primera derivada de segundo o tercer orden, vamos a mostrar el procedimiento, para ello usamos la serie de Taylor truncada y substituimos \\(x\\) por \\(x_0+h\\) y \\(x_0-h\\) respectivamente:\n\\[f(x_0+h) = f(x_0) + \\frac{f^{(1)}(x_0)}{1!}h + \\frac{f^{(2)}(x_0)}{2!}h^2 + \\frac{f^{(3)}(x_0)}{3!}h^3 +  \\frac{f^{(iv)}(x_0)}{4!}h^4 +\\cdots\\]\ny\n\\[f(x_0-h) = f(x_0) - \\frac{f^{(1)}(x_0)}{1!}h + \\frac{f^{(2)}(x_0)}{2!}h^2 - \\frac{f^{(3)}(x_0)}{3!}h^3 +  \\frac{f^{(iv)}(x_0)}{4!}h^4 -\\cdots\\]\nrestando estas dos ecuaciones obtenemos:\n\\[f(x_0+h) - f(x_0-h) = 2f^{(1)}(x_0)h + 2\\frac{f^{(3)}(x_0)}{3!}h^3 + 2\\frac{f^{(5)}(x_0)}{5!}h^5 + \\cdots\\]\nAl despexar \\(f^{(1)}(x_0)\\) obtenemos:\n\\[f^{(1)}(x_0) = \\frac{f(x_0+h) - f(x_0-h)}{2h} - \\frac{f^{(3)}(x_0)}{3!}h^2 - \\frac{f^{(5)}(x_0)}{5!}h^4 - \\cdots\\] \\[f^{(1)}(x_0) \\approx \\frac{f(x_0+h) - f(x_0-h)}{2h}+\\mathcal{O}(h^2)\\]\nNote que esta aproximación es de segundo orden pero necesita evaluar la función en tres puntos distintos, \\(x_0\\), \\(x_0+h\\) y \\(x_0-h\\). De aqui podemos concluir que podemos hacer aproximaciones de la primera derivada de mayor orden pero para ello necesitamos evaluar la función en más puntos. Supongamso que queremos crear una aproximación de la primera derivada de orden 3, centrada en el punto \\(x_0\\), como muestra la figura:\n\nUsando la serie de Taylor truncada en \\(x_0-h\\), \\(x_0\\),\\(x_0+h\\) y \\(x_0+2h\\) obtenemos:\n\\[\\begin{align}\nf(x_0-h) &= f(x_0) - \\frac{f^{(1)}(x_0)}{1!}h + \\frac{f^{(2)}(x_0)}{2!}h^2 - \\frac{f^{(3)}(x_0)}{3!}h^3 +  \\frac{f^{(iv)}(x_0)}{4!}h^4 -\\cdots\\\\\nf(x_0) &= f(x_0)\\\\\nf(x_0+h) &= f(x_0) + \\frac{f^{(1)}(x_0)}{1!}h + \\frac{f^{(2)}(x_0)}{2!}h^2 + \\frac{f^{(3)}(x_0)}{3!}h^3 +  \\frac{f^{(iv)}(x_0)}{4!}h^4 +\\cdots\\\\\nf(x_0+2h)&= f(x_0) + 2\\frac{f^{(1)}(x_0)}{1!}h + 4\\frac{f^{(2)}(x_0)}{2!}h^2 + 8\\frac{f^{(3)}(x_0)}{3!}h^3 +  16\\frac{f^{(iv)}(x_0)}{4!}h^4 +\\cdots \\end{align}\\]\nde estas ecuaciones, queremos construir un sistema de ecuaciones lineales, para ello multiplicamos cada ecuación anterior por un factor y las sumamos, de esta forma: \\[\\begin{align}\n{\\color{red}a_1}f(x_0-h) &={\\color{red}a_1}\\Big( f(x_0) - \\frac{f^{(1)}(x_0)}{1!}h + \\frac{f^{(2)}(x_0)}{2!}h^2 - \\frac{f^{(3)}(x_0)}{3!}h^3 +  \\frac{f^{(iv)}(x_0)}{4!}h^4 -\\cdots\\Big)\\\\\n{\\color{red}a_2}f(x_0) &= {\\color{red}a_2}f(x_0)\\\\\n{\\color{red}a_3}f(x_0+h) &= {\\color{red}a_3}\\Big(f(x_0) + \\frac{f^{(1)}(x_0)}{1!}h + \\frac{f^{(2)}(x_0)}{2!}h^2 + \\frac{f^{(3)}(x_0)}{3!}h^3 +  \\frac{f^{(iv)}(x_0)}{4!}h^4 +\\cdots\\Big)\\\\\n{\\color{red}a_4}f(x_0+2h)&= {\\color{red}a_4}\\Big(f(x_0) + 2\\frac{f^{(1)}(x_0)}{1!}h + 4\\frac{f^{(2)}(x_0)}{2!}h^2 + 8\\frac{f^{(3)}(x_0)}{3!}h^3 +  16\\frac{f^{(iv)}(x_0)}{4!}h^4 +\\cdots\\Big) \\end{align}\\]\nde esta forma construimos el sistema\n\\[\\begin{align}a_1f(x_0-h) + a_2f(x_0) + a_3f(x_0+h) + a_4f(x_0+2h) &= \\\\\n&f(x_0)(a_1+a_2+a_3+a_4)+\\frac{f^{(1)}(x_0)}{1!}h\\Big(-a_1+a_3+2a_4\\Big)+\\frac{f^{(2)}(x_0)}{2!}h^2\\Big(a_1+a_3+4a_4\\Big)\\\\\n&+\\frac{f^{(3)}(x_0)}{3!}h^3\\Big(-a_1+a_3+8a_4\\Big)+\\cdots\n\\end{align}\\]\nNote para que la aproximación sea de orden 3, necesitamos que los coeficientes de \\(f(x_0)\\) y \\(f^{(2)}(x_0)\\) y \\(f^{(3)}\\) sean cero y el coeficiente de \\(f^{(1)}(x_0)\\) sea \\(\\frac{1}{h}\\) de esta forma obtenemos el sistema de ecuaciones:\n\\[\\begin{align}a_1+a_2+a_3+a_4 &= 0\\\\\n-a_1+a_3+2a_4 &= \\frac{1}{h}\\\\\na_1+a_3+4a_4 &= 0\\\\\n-a_1+a_3+8a_4 &= 0\n\\end{align}\\]\nde esta forma encontramos que la ssolución del sistema es \\(a_1=a_3=\\frac{1}{12h}\\) y \\(a_2=a_4=-\\frac{2}{3h}\\), por lo tanto la aproximación de la primera derivada de orden 3 es:\n\nimport sympy as sp\n\n\n\n# Define the variables\na1,a2,a3,a4, h = sp.symbols('a_1 a_2 a_3 a_4 h')\n\n# Define the equations\neq1 = sp.Eq(a1+a2+a3+a4, 0)\neq2 = sp.Eq(-a1+a3+2*a4, 1/h)\neq3 = sp.Eq(a1+a3+4*a4, 0)\neq4 = sp.Eq(-a1+a3+8*a4, 0)\n\n# Solve the system of equations\nsolution = sp.solve((eq1,eq2,eq3,eq4), (a1,a2,a3,a4))\n\nsolution\n\n\n\n{a_1: -1/(3*h), a_2: -1/(2*h), a_3: 1/h, a_4: -1/(6*h)}\n\n\nusnado sympy podemos encontrar la aproximación de la primera derivada de orden 3:\n\\[f(x_0)=-\\frac{1}{3h}f(x_0-h)+\\frac{1}{2h}f(x_0)+\\frac{1}{h}f(x_0+h)-\\frac{1}{6h}f(x_0+2h)+\\mathcal{O}(h^3)\\]\nnote que ahciendo un procedimiento similar podemos encontrar la aproximación de la primera derivada de orden 5, 7, 9, etc. Adicionalmente podemos encontrar la aproximación de la segunda derivada de orden 2, 4, 6, etc.\nAproximación de la segunda derivada\nUsando la serie de Taylor truncada en \\(x_0-h\\), \\(x_0\\),\\(x_0+h\\) y \\(x_0+2h\\) obtenemos:\n\\[\\begin{align}\nf(x_0-h) &= f(x_0) - \\frac{f^{(1)}(x_0)}{1!}h + \\frac{f^{(2)}(x_0)}{2!}h^2 - \\frac{f^{(3)}(x_0)}{3!}h^3 +  \\frac{f^{(iv)}(x_0)}{4!}h^4 -\\cdots\\\\\nf(x_0) &= f(x_0)\\\\\nf(x_0+h) &= f(x_0) + \\frac{f^{(1)}(x_0)}{1!}h + \\frac{f^{(2)}(x_0)}{2!}h^2 + \\frac{f^{(3)}(x_0)}{3!}h^3 +  \\frac{f^{(iv)}(x_0)}{4!}h^4 +\\cdots\\\\\n\\end{align}\\]\nde estas ecuaciones, queremos construir un sistema de ecuaciones lineales, para ello multiplicamos cada ecuación anterior por un factor y las sumamos, de esta forma:\n\\[\\begin{align}\n{\\color{red}a_1}f(x_0-h) &={\\color{red}a_1}\\Big( f(x_0) - \\frac{f^{(1)}(x_0)}{1!}h + \\frac{f^{(2)}(x_0)}{2!}h^2 - \\frac{f^{(3)}(x_0)}{3!}h^3 +  \\frac{f^{(iv)}(x_0)}{4!}h^4 -\\cdots\\Big)\\\\\n{\\color{red}a_2}f(x_0) &= {\\color{red}a_2}f(x_0)\\\\\n{\\color{red}a_3}f(x_0+h) &= {\\color{red}a_3}\\Big(f(x_0) + \\frac{f^{(1)}(x_0)}{1!}h + \\frac{f^{(2)}(x_0)}{2!}h^2 + \\frac{f^{(3)}(x_0)}{3!}h^3 +  \\frac{f^{(iv)}(x_0)}{4!}h^4 +\\cdots\\Big)\n\\end{align}\\]\nAsí tenemos el sistema de ecuaciones:\n\\[\\begin{align}\na_1f(x_0-h) + a_2f(x_0) + a_3f(x_0+h) &= \\\\\n&f(x_0)(a_1+a_2+a_3)+\\frac{f^{(1)}(x_0)}{1!}h\\Big(-a_1+a_3\\Big)+\\frac{f^{(2)}(x_0)}{2!}h^2\\Big(a_1+a_3\\Big)\\\\\n&+\\frac{f^{(3)}(x_0)}{3!}h^3\\Big(-a_1+a_3\\Big)+\\frac{f^{(3)}(x_0)}{4!}h^4\\Big(a_1+a_3\\Big)\\cdots\n\\end{align}\\]\nNote que para aproximar la segunda derivada de orden 2, necesitamos que los coeficientes de \\(f(x_0)\\) y \\(f^{(3)}(x_0)\\) sean cero y el coeficiente de \\(f^{(1)}(x_0)\\) sea \\(\\frac{1}{h^2}\\) de esta forma obtenemos el sistema de ecuaciones:\n\\[\\begin{align}\na_1+a_2+a_3 &= 0\\\\\n-a_1+a_3 &= 0\\\\\na_1+a_3 &= \\frac{1}{h^2}\n\\end{align}\\]\n\nimport sympy as sp\n\n\n\n# Define the variables\na1,a2,a3, h = sp.symbols('a_1 a_2 a_3 h')\n\n# Define the equations\neq1 = sp.Eq(a1+a2+a3, 0)\neq2 = sp.Eq(-a1+a3, 0)\neq3 = sp.Eq(a1+a3, 2/h**2)\n\n\n# Solve the system of equations\nsolution = sp.solve((eq1,eq2,eq3), (a1,a2,a3))\n\nsolution\n\n{a_1: h**(-2), a_2: -2/h**2, a_3: h**(-2)}\n\n\ncomo \\(a_1\\) y \\(a_3\\) son iguales note que el termino de la tercera derivada se anula, por lo tanto la aproximación es de segundo orden y es de la forma\n\\[\\frac{f(x_0+h)-2f(x_0)+f(x_0-h)}{h^2}=f^{(2)}(x_0)+\\mathcal{O}(h^2)\\]\n\n\n\nSupongamos que tenemos una lista de puntos \\((x_i,y_i)\\), \\(i=0,1,2,\\cdots,n\\) donde los puntos \\(x_i\\) son equiespaciados y queremos aproximar la derivada de la función \\(f(x)\\) en el punto \\(x_i\\), para ello podemos usar la aproximación de la derivada de orden 1, 2, centrada en el punto \\(x_i\\), de esta forma:\nPara el primer orden de aproximación: \\[f'(x_i) \\approx \\frac{f(x_i+h) - f(x_i)}{h}\\] para el segundo orden de aproximación: \\[f'(x_i) \\approx \\frac{f(x_i) - f(x_i-h)}{h}\\]\nNote que para el primer orden solo se puede aproximar las derivadas de los puntos \\(x_0\\) hasta \\(x_{n-1}\\) y para el segundo orden solo se puede aproximar las derivadas de los puntos \\(x_1\\) hasta \\(x_{n}\\)**.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the function\ndef f(x):\n    return x**3+2\n\n# Derivate of the function\ndef df(x):\n    return 3*x**2\n# Define the interval\na = 0\nb = 1\nx,h = np.linspace(a,b,100,retstep=True)\ny=f(x)\ndf= df(x)\n# Plot the function\nplt.plot(x,y, label='f(x)')\nplt.plot(x,df, label='df(x)')\nplt.title('Function and real derivate')\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n## aproximate the derivate of firth order\n\ndf1=(y[1:]-y[0:-1])/h\ndf2=(y[2:]-y[0:-2])/(2*h)\nplt.plot(x[0:-1],df1, label='1 order df(x)')\nplt.plot(x[0:-2],df2, label='2 order df(x)')\nplt.plot(x,df, label='real df(x)')   \nplt.grid()\nplt.title('Function and aproximate derivate')\nplt.legend()\nplt.show()\n\n\n\n\nSi calculamos el error de cada aproximación obtenemos:\n\n## Error de aproximacion\n\nerror1=np.linalg.norm(df1-df[0:-1])\nerror2=np.linalg.norm(df2-df[1:-1])\nprint('error1=',error1)\nprint('error2=',error2)\n\nerror1= 0.17363602561208802\nerror2= 0.001010049478277235\n\n\nNote que se hace evidente que la aproximación de primer orden es de orden 1 es peor que la aproximación de segundo orden es de orden 2."
  },
  {
    "objectID": "ode_euler.html",
    "href": "ode_euler.html",
    "title": "Simulación de ecuaciones diferenciales",
    "section": "",
    "text": "Las ecuaciones diferenciales se caracterizan por tener multiples aplicaciones en casi todas las áreas del conocimiento. En algunos “pocos” casos se puede encontrar la solución analítica de las mismas, por lo general se aproxima la soluciones de las ecuaciones diferenciales usando métodos numéricos. Los métodos más simples es el método de Euler (implícito y explicito), el cual lo vamos a deducir en este notebook.\n\n\nSupongamos que tenemos la ecuación diferencial ordinaria (EDO) de primer orden:\n\\[\\frac{dy}{dt} = f(t,y)\\] para \\(t \\in [t_0, t_f]\\) y \\(y(t_0) = y_0\\).\npodemos integrar la ecuación diferencial de la siguiente manera:\n\\[\\int_{t_0}^{t_f} \\frac{dy}{dt} dt = \\int_{t_0}^{t_f} f(t,y) dt\\] e usando el primer teorema del cálculo obtenemos:\n\\[y(t_f) - y(t_0) = \\int_{t_0}^{t_f} f(t,y) dt\\] \\[y(t_f) = y(t_0) + \\int_{t_0}^{t_f} f(t,y) dt\\] de esta forma podríamos buscar alguna alternativa para aproximar la integral, lo cual nos lleva a la siguiente aproximación:\n\\[\\int_{t_0}^{t_f} f(t,y) dt \\approx  f(t_0,y_0) \\Delta t,\\] de esta forma obtenemos que el valor de \\(y\\) en el tiempo \\(t_f\\) es:\n\\[y(t_f) \\approx y(t_0) + f(t_0,y_0) \\Delta t.\\]\nSi usamos este porcedimiento de forma iterativa podemos obtener la solución de la EDO en el intervalo \\([t_0, T ]\\), de la siguiente manera:\n\nGenerar una partición del intervalo \\([t_0, T ]\\) con \\(N\\) puntos, es decir, \\(t_0, t_1, t_2, \\dots, t_N\\).\nUsando la aproximación anterior podemos obtener el valor de \\(y\\) en cada uno de los puntos de la partición, de la siguiente manera:\n\n\\[y_{i+1} = y_i + f(t_i,y_i) \\Delta t,\\]\npara \\(i = 0, 1, 2, \\dots, N-1\\). 3. Obtenemos la solución aproximada de la EDO es la lista de valores \\(y_0, y_1, y_2, \\dots, y_N\\).\n\n\n\nConsideremos la siguiente EDO:\n\\[\\frac{dy}{dt} = -y\\] para \\(t \\in [0, 1]\\) y \\(y(0) = 1\\).\nLa solución analítica de esta EDO es:\n\\[y(t) = e^{-t}.\\]\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef ode_euler(f, x0, t):\n    \"\"\"Approximate the solution of x' = f(x,t) by Euler's method.\n\n    Parameters\n    ----------\n    f : function\n        Right-hand side of the differential equation x' = f(x,t), x(t0)=x0\n    x0 : number\n        Initial value of x\n    t : array\n        1D NumPy array of t values where we approximate x values. Time step\n        at each iteration is given by t[n+1] - t[n].\n\n    Returns\n    -------\n    x : 1D NumPy array\n        Approximation of the solution at values `t` with x[0] = x0.\n    \"\"\"\n    x = np.zeros(len(t))\n    x[0] = x0\n    for n in range(0, len(t) - 1):\n        x[n + 1] = x[n] + f(x[n], t[n]) * (t[n + 1] - t[n])\n    return x\n\ndef f(x, t):\n    return -x\n\nt,h = np.linspace(0, 1, 100, retstep=True)\n\nx = ode_euler(f, 1, t)\n\nplt.plot(t, x, 'o-', label='Euler')\nplt.plot(t, np.exp(-t), label='Exact')\nplt.legend(loc='upper right')\nplt.xlabel('t')\nplt.ylabel('x')\nplt.show()"
  },
  {
    "objectID": "ode_euler.html#método-de-euler",
    "href": "ode_euler.html#método-de-euler",
    "title": "Simulación de ecuaciones diferenciales",
    "section": "Método de Euler",
    "text": "Método de Euler\nSupongamos que tenemos la ecuación diferencial ordinaria (EDO) de primer orden:\n\\[\\frac{dy}{dt} = f(t,y)\\] para \\(t \\in [t_0, t_f]\\) y \\(y(t_0) = y_0\\).\npodemos integrar la ecuación diferencial de la siguiente manera:\n\\[\\int_{t_0}^{t_f} \\frac{dy}{dt} dt = \\int_{t_0}^{t_f} f(t,y) dt\\] e usando el primer teorema del cálculo obtenemos:\n\\[y(t_f) - y(t_0) = \\int_{t_0}^{t_f} f(t,y) dt\\] \\[y(t_f) = y(t_0) + \\int_{t_0}^{t_f} f(t,y) dt\\] de esta forma podríamos buscar alguna alternativa para aproximar la integral, lo cual nos lleva a la siguiente aproximación:\n\\[\\int_{t_0}^{t_f} f(t,y) dt \\approx  f(t_0,y_0) \\Delta t,\\] de esta forma obtenemos que el valor de \\(y\\) en el tiempo \\(t_f\\) es:\n\\[y(t_f) \\approx y(t_0) + f(t_0,y_0) \\Delta t.\\]\nSi usamos este porcedimiento de forma iterativa podemos obtener la solución de la EDO en el intervalo \\([t_0, T ]\\), de la siguiente manera:\n\nGenerar una partición del intervalo \\([t_0, T ]\\) con \\(N\\) puntos, es decir, \\(t_0, t_1, t_2, \\dots, t_N\\).\nUsando la aproximación anterior podemos obtener el valor de \\(y\\) en cada uno de los puntos de la partición, de la siguiente manera:\n\n\\[y_{i+1} = y_i + f(t_i,y_i) \\Delta t,\\]\npara \\(i = 0, 1, 2, \\dots, N-1\\). 3. Obtenemos la solución aproximada de la EDO es la lista de valores \\(y_0, y_1, y_2, \\dots, y_N\\)."
  },
  {
    "objectID": "ode_euler.html#ejemplo",
    "href": "ode_euler.html#ejemplo",
    "title": "Simulación de ecuaciones diferenciales",
    "section": "Ejemplo",
    "text": "Ejemplo\nConsideremos la siguiente EDO:\n\\[\\frac{dy}{dt} = -y\\] para \\(t \\in [0, 1]\\) y \\(y(0) = 1\\).\nLa solución analítica de esta EDO es:\n\\[y(t) = e^{-t}.\\]\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef ode_euler(f, x0, t):\n    \"\"\"Approximate the solution of x' = f(x,t) by Euler's method.\n\n    Parameters\n    ----------\n    f : function\n        Right-hand side of the differential equation x' = f(x,t), x(t0)=x0\n    x0 : number\n        Initial value of x\n    t : array\n        1D NumPy array of t values where we approximate x values. Time step\n        at each iteration is given by t[n+1] - t[n].\n\n    Returns\n    -------\n    x : 1D NumPy array\n        Approximation of the solution at values `t` with x[0] = x0.\n    \"\"\"\n    x = np.zeros(len(t))\n    x[0] = x0\n    for n in range(0, len(t) - 1):\n        x[n + 1] = x[n] + f(x[n], t[n]) * (t[n + 1] - t[n])\n    return x\n\ndef f(x, t):\n    return -x\n\nt,h = np.linspace(0, 1, 100, retstep=True)\n\nx = ode_euler(f, 1, t)\n\nplt.plot(t, x, 'o-', label='Euler')\nplt.plot(t, np.exp(-t), label='Exact')\nplt.legend(loc='upper right')\nplt.xlabel('t')\nplt.ylabel('x')\nplt.show()"
  },
  {
    "objectID": "ode_euler.html#método-del-trapecio",
    "href": "ode_euler.html#método-del-trapecio",
    "title": "Simulación de ecuaciones diferenciales",
    "section": "Método del Trapecio",
    "text": "Método del Trapecio\nAhora si usamos la aproximación de la integral por el método del trapecio obtenemos el siguiente método:\n\\[\\int_{t_0}^{t_f} f(t,y) dt \\approx  \\frac{f(t_0,y_0) + f(t_f,y_f)}{2} \\Delta t,\\]\nen este caso obtenemos el método del trapecio, el cual es:\n\\[y_{i+1} = y_i + \\frac{f(t_i,y_i) + f(t_{i+1},y_{i+1})}{2} \\Delta t,\\]\nNote que este método también es implícito.\nEjercicio 1. Implemente el método del trapecio para resolver la EDO del ejemplo anterior.\n\nEncuentre la solución de la EDO usando el método de Euler explicito, implícito y el método del trapecio.\nGrafique la solución analítica y las soluciones aproximadas usando los tres métodos.Sin título\nSolucione la siguiente EDO usando el método de Euler explicito, implícito y el método del trapecio. \\[\\frac{dy}{dt} = -y + t^2 \\] para \\(t \\in [0, 1]\\) y \\(y(0) = 0\\).\nCalcule la solución exacta usando sympy (ver el siguiente ejemplo) y calcule el error de cada método.\n\n\nimport sympy as sp\n\n# Define the symbols\nt = sp.symbols('t')\ny = sp.Function('y')(t)\n\n# Define the ODE\node = sp.Eq(y.diff(t), -y + t**2 + 1)\n\n# Solve the ODE\nsol = sp.dsolve(ode, y)\n\n# Find the constant using the initial condition\nC_eq = sp.Eq(sol.rhs.subs(t, 0), 0)\nC_sol = sp.solve(C_eq)\n\n# Substitute the constant into the solution\nsol = sol.subs('C1', C_sol[0])\n\nprint(\"The solution to the ODE is:\", sol)\nsol\n\nThe solution to the ODE is: Eq(y(t), t**2 - 2*t + 3 - 3*exp(-t))\n\n\n\\(\\displaystyle y{\\left(t \\right)} = t^{2} - 2 t + 3 - 3 e^{- t}\\)\n\n\n\nSolucione la siguiente EDO usando el método de Euler explicito, implícito y el método del trapecio. \\[\\frac{dy}{dt} = -\\lambda(y-\\cos(t))-\\sin t\\] Note que la solución de la ecuación diferencial es \\(y(t) =\\cos t\\), para \\(t \\in [0, 1]\\) y \\(y(0) = 0\\) y \\(\\lambda=\\pm 1,\\pm 10,\\pm 100\\)"
  },
  {
    "objectID": "ode_euler.html#ecuaciones-rígidas",
    "href": "ode_euler.html#ecuaciones-rígidas",
    "title": "Simulación de ecuaciones diferenciales",
    "section": "Ecuaciones rígidas",
    "text": "Ecuaciones rígidas\nLas ecuaciones diferenciales rígidas son aquellas que tienen soluciones que varían rápidamente en un intervalo pequeño y lentamente en un intervalo grande. Por ejemplo, considere la siguiente EDO: \\[\\frac{dy}{dt} = \\lambda y\\] para \\(t \\in [0, 1]\\) y \\(y(0) = 1\\). Note que para \\(\\lambda\\) grande la ecuación varia rápidamente en un intervalo pequeño y lentamente en un intervalo grande. La ecuaciones rígidas no se pueden aproximar usando métodos explícitos como el método de Euler explicito, ya que el paso de integración debe ser muy pequeño para que el método sea estable. Por lo general se usan métodos implícitos para resolver ecuaciones rígidas."
  },
  {
    "objectID": "ode_euler.html#método-de-runge-kutta-de-orden-4",
    "href": "ode_euler.html#método-de-runge-kutta-de-orden-4",
    "title": "Simulación de ecuaciones diferenciales",
    "section": "Método de Runge-Kutta de orden 4",
    "text": "Método de Runge-Kutta de orden 4\nEl método de Runge-Kutta de orden 4 es un método de Runge-Kutta de la siguiente forma:\n\\[y_{i+1} = y_i + \\frac{1}{6}(k_1 + 2k_2 + 2k_3 + k_4)\\] \\[t_{i+1} = t_i + \\Delta t\\] donde \\[k_1 = f(t_i,y_i) \\Delta t\\] \\[k_2 = f(t_i + \\frac{\\Delta t}{2},y_i + \\frac{k_1}{2}) \\Delta t\\] \\[k_3 = f(t_i + \\frac{\\Delta t}{2},y_i + \\frac{k_2}{2}) \\Delta t\\] \\[k_4 = f(t_i + \\Delta t,y_i + k_3) \\Delta t\\]\nEste método es de cuarto orden de aproximación y es explicito."
  },
  {
    "objectID": "ode_euler.html#ejercicio",
    "href": "ode_euler.html#ejercicio",
    "title": "Simulación de ecuaciones diferenciales",
    "section": "Ejercicio",
    "text": "Ejercicio\nImplemente el método de Runge-Kutta de orden 4 para resolver la EDO del ejemplo anterior."
  },
  {
    "objectID": "ode_euler.html#libreria-scipy.integrate",
    "href": "ode_euler.html#libreria-scipy.integrate",
    "title": "Simulación de ecuaciones diferenciales",
    "section": "Libreria scipy.integrate",
    "text": "Libreria scipy.integrate\nLa libreria scipy.integrate tiene funciones para resolver ecuaciones diferenciales ordinarias. En particular tiene la función odeint es una librería que se usa para resolver ecuaciones diferenciales ordinarias la cual usa la librería odepack de FORTRAN. Actualmente esta librería esta en desuso y se recomienda usar la función solve_ivp ode_ivp, que la cual usted puede escoger el método de integración que desea usar. En el siguiente ejemplo vamos a usar la función odeint para resolver la EDO del ejemplo anterior.\n\nimport numpy as np\nfrom scipy.integrate import odeint\n\n# Define the ODE\ndef dydt(y, t):\n    return -y + t**2 + 1\n\n# Define the initial condition\ny0 = 0\n\n# Define the time points where the solution is computed\nt = np.linspace(0, 2, 100)\n\n# Solve the ODE\ny = odeint(dydt, y0, t)\n\n# Plot the solution\nimport matplotlib.pyplot as plt\nplt.plot(t, y)\nplt.xlabel('t')\nplt.ylabel('y(t)')\nplt.show()\n\n\n\n\n\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nimport matplotlib.pyplot as plt\n\n# Define the ODE\ndef dydt(t, y):\n    return -y + t**2 + 1\n\n# Define the initial condition\ny0 = [0]\n\n# Define the time span\nt_span = [0, 2]\n\n# Solve the ODE using the Runge-Kutta method\nsol = solve_ivp(dydt, t_span, y0, method='RK45', t_eval=np.linspace(*t_span, 100))\n\n# Plot the solution\nplt.plot(sol.t, sol.y[0])\nplt.xlabel('t')\nplt.ylabel('y(t)')\nplt.show()"
  },
  {
    "objectID": "taller_repaso_final.html",
    "href": "taller_repaso_final.html",
    "title": "clases",
    "section": "",
    "text": "Observe las siguiente tabla de puntos\n\n\n\n\nsplines.png\n\n\n\nUse su programa para encontrar el polinomio interpolador\nUse splines cubicos e interpole los puntos\n\n\nSea los siguientes puntos\n\n\n\n\n\\(x_i\\)\n\\(y_i\\)\n\n\n\n\n0.1\n0.09983342\n\n\n0.2\n0.19866933\n\n\n0.3\n0.29552021\n\n\n0.4\n0.38941834\n\n\n0.5\n0.47942554\n\n\n0.6\n0.56464247\n\n\n0.7\n0.64421769\n\n\n0.8\n0.71735609\n\n\n\n\nEncuentre el polinomio que interpola estos puntos usando un sistema de ecuaciones generado\nUse su programa para encontrar el polinomio interpolador\nUse splines cúbicos e interpole los puntos\nGrafique los polinomios obtenidos en cada uno de los puntos anteriores y compare con la función \\(f(x)=\\sin(x)\\)\n\n\nEncuentre la aproximación de \\[\nu'(x) = c_{-2} u(x-2h) + c_{-1} u(x-h) + c_0u(x) + c_1u(x+h) +\nc_2u(x+2h) + O(h^4).\n\\]\nEncuentre la aproximacion de \\[u''(x) = c_{-2} u(x-2h) + c_{-1} u(x-h) + c_0u(x) + c_1u(x+h) +\nc_2u(x+2h) + O(h^4).\\]\nTeste la formula para cinco puntos para aproximar \\(u''(1)\\) usando \\(u(x) = \\sin(2x)\\) con valores de \\(h\\) desde el siguiente vector {}. Haga una tabla del error versus\nel valor de \\(h\\). ¿De que orden es el error?\nSea la siguiente familia de puntos\n\n\n\n\n\\(x_i\\)\n\\(y_i\\)\n\n\n\n\n1.3\n4\n\n\n1.0\n13\n\n\n1.5\n8\n\n\n1.1\n26\n\n\n1.7\n-1\n\n\n\nEncuentre \\(y'\\) de primer y segundo orden en el punto $\\(1.7\\).\n\nEn un circuito con un voltaje impreso \\(e(t)\\) y una inductancia\n\n\nLa primera ley de Kirchhoff nos da la siguiente relación \\[e(t)=L\\frac{di}{dt}+Ri\\] donde \\(R\\) es la resistencia del circuito e \\(i\\) es la corriente. Suponga que mediante la corriente con varios valores de \\(t\\) y obtenemos \\begin{center}\n\n\n\n\n\\(t\\)\n\\(i\\)\n\n\n\n\n1.0\n3.10\n\n\n1.01\n3.12\n\n\n1.02\n3.14\n\n\n1.03\n3.18\n\n\n1.04\n3.24\n\n\n\ndonde \\(t\\) se mide en segundos. \\(i\\) se da en amperes, la inductancia L es una constante de 0.98 henries y la resistencia es de 0.142 ohms. Aproxime \\(\\frac{di}{dt}\\).\n\nAproxime la integral \\(\\int_0^2x^2ln(x^2+1)\\,dx\\) usando \\(h=1/3\\) Use\n\n\nLa regla del trapecio\nLa regla de Simpsoms 1/3\nLa regla de Simpsoms 3/8\n\n\nDetermine el valor de \\(n\\) (número de puntos) y de \\(h\\) que se requiere para aproximar \\(\\int_0^2 e^{2x}\\sin(3x)\\,dx\\), esperando que el error total sea menor que \\(10^{-4}\\), usando\n\n\nLa regla del trapecio\nLa regla de Simpsoms 1/3\nLa regla de Simpsoms 3/8\n\n\n\nRealice una tabla de comparación de los métodos Euler implicito, Euler explicito y Runge-Kutta de orden 4\nSolucione el siguiente problema de valor inicial \\[ \\frac{dy}{dt}=y-t^2+1, \\quad 0\\leq t \\leq 2, \\quad y(0)=0.5\\] con \\(h=0.2,0.1,0.05\\) usando\n\n\nEuler implícito\nEuler explicito\nRunge-Kutta de orden 4\n\nEncuentre el error en cada uno de los métodos para cada \\(h\\) y comparelos"
  },
  {
    "objectID": "ode_euler.html#ejemplo-1",
    "href": "ode_euler.html#ejemplo-1",
    "title": "Simulación de ecuaciones diferenciales",
    "section": "Ejemplo",
    "text": "Ejemplo\nVamos a modificar el ejemplo anterior para usar el método de Euler implícito.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef sol_newton(gg,dgg, x0,t1,dt, tol=1e-10):\n    \"\"\" Find a solution of f(x)=0 given an initial approximation x0.\n    Parameters\n    ---\n    f : function\n        Function for which we are trying to find a solution f(x)=0.\n    df : function\n        Derivative of f(x).\n    x0 : number\n       value of x in the n step\n    t1 : number \n        value of t in the n+1 step\n    tol : number\n    Returns\n    ---\n    x : number\n        Approximate solution satisfying f(x)=0 within the given tolerance.\n    True if the algorithm converged and False otherwise.\n    \"\"\"\n\n    max_iter = 400\n    x = x0\n    for i in range(max_iter):\n        if dgg(x,x0,t1,dt)==0:\n            x=np.nan\n            sol=False\n            return x,sol\n       \n        x = x - gg(x,x0,t1,dt)/dgg(x,x0,t1,dt)\n\n       \n        \n        if abs(gg(x,x0,t1,dt)) < tol:\n            sol=True\n            return x,sol\n        x=x0\n    sol=False\n    x=np.nan\n    return x,sol\n\ndef g(x,x0,t1,dt):\n    '''\n    Function to find the root of the implicit equation\n    Parameters\n    ---\n    x : number\n        value of x in the n+1 step\n    x0 : number\n        value of x in the n step\n    t1 : number\n        value of t in the n+1 step\n    ---\n    Return \n    valune of the function\n    '''\n    \n    \n    \n    return x - x0 - f(x, t1)*dt\n\ndef dg(x,x0,t1,dt):\n    '''\n    Derivate of function to find the root of the implicit equation\n    parameters\n    ---\n    x : number\n        value of x in the n+1 step\n    x0 : number\n        value of x in the n step\n    t1 : number\n        value of t in the n+1 step\n    Returns\n    ----\n    value of the derivative of the function\n    '''\n    return 1.0 - df(x, t1)*dt\n\ndef ode_euler_impl(f,df,x0,t):\n    \"\"\"Approximate the solution of x' = f(x,t) by implicit Euler's method.\n\n    Parameters\n    ----------\n    f : function\n        Right-hand side of the differential equation x' = f(x,t), x(t0)=x0\n    df : function\n        Derivative of f(x,t) with respect to x\n    x0 : number\n        Initial value of x\n    t : array\n        1D NumPy array of t values where we approximate x values. Time step\n        at each iteration is given by t[n+1] - t[n].\n\n    Returns\n    -------\n    x : 1D NumPy array\n        Approximation of the solution at values `t` with x[0] = x0.\n    \"\"\"\n    x = np.zeros(len(t))\n    x[0] = x0\n    for n in range(0, len(t) - 1):\n        dt= (t[n + 1] - t[n])\n        x_tem, sol = sol_newton(g,dg, x[n],t[n+1],dt,tol=1e-10)\n        if sol==False:\n            print(\"No se pudo encontrar la solución\")\n            break\n        x[n + 1] = x_tem\n    return x\n## Function f(x,t)\ndef f(x, t):\n    return -x\n## Derivate of función f(x,t) with respect to x\ndef df(x, t):\n    return -1.0\nt,h = np.linspace(0, 1, 100, retstep=True)\n\nx = ode_euler_impl(f, df,1, t)\n\nplt.plot(t, x, 'o-', label='Euler')\nplt.plot(t, np.exp(-t), label='Exact')\nplt.legend(loc='upper right')\nplt.xlabel('t')\nplt.ylabel('x')\nplt.show() \n\n\n\n\n\ndf(1.0,3)\n\n-1"
  }
]